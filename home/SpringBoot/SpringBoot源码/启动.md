# springBoot启动分析

## 1.springBoot 启动类

```java
//使用war包部署(也就是放到tomcat运行)时就要继承 SpringBootServletInitializer 类,重写 configure 方法
@SpringBootApplication(scanBasePackages = { "com.zjcpo.admin" })
public class ApplicationBootstrap extends SpringBootServletInitializer {

    @Override
    protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {
        return application.sources(ApplicationBootstrap.class);
    }

    public static void main(String[] args) {
        SpringApplication.run(ApplicationBootstrap.class, args);
    }

}

```

## 1.@SpringBootApplication注解,用来替代@SpringBootConfiguration,@EnableAutoConfiguration,@ComponentScan注解

1. @SpringBootConfiguration 继承自@Configuration注解,表示当前是配置类


```java
//基于xml形式的配置类
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"
       default-lazy-init="true">
    <!--bean定义-->
    <bean id="mockService" class="..MockServiceImpl">
    ...
    </bean>
</beans>

//基于javaConfig形式的配置类
@Configuration
public class MockConfiguration{
    //bean定义
     @Bean
    public MockService mockService(){
        return new MockServiceImpl();
    }
}
```

2. @EnableAutoConfiguration 依靠@AutoConfigurationPackage和@Import实现自动化配置

```java
@AutoConfigurationPackage
@Import({EnableAutoConfigurationImportSelector.class})
public @interface EnableAutoConfiguration {
    String ENABLED_OVERRIDE_PROPERTY = "spring.boot.enableautoconfiguration";

    Class<?>[] exclude() default {};

    String[] excludeName() default {};
}

```

3. @ComponentScan扫描指定的包路径，若未指定包路径，则以声明这个注解的类作为基本包路径。比如@SpringBootApplication就没有指定包路径，则DemoApplication的包路径将作为扫描的基本包路径，因此强烈建议将主类放在顶层目录下。  
excludeFilters属性指定哪些类型不符合组件扫描的条件，会在扫描的时候过滤掉。

```java
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(
    excludeFilters = {@Filter(
    type = FilterType.CUSTOM,
    classes = {TypeExcludeFilter.class}
), @Filter(
    type = FilterType.CUSTOM,
    classes = {AutoConfigurationExcludeFilter.class}
)}
)
public @interface SpringBootApplication {
    @AliasFor(
        annotation = EnableAutoConfiguration.class,
        attribute = "exclude"
    )
    Class<?>[] exclude() default {};

    @AliasFor(
        annotation = EnableAutoConfiguration.class,
        attribute = "excludeName"
    )
    String[] excludeName() default {};

    @AliasFor(
        annotation = ComponentScan.class,
        attribute = "basePackages"
    )
    String[] scanBasePackages() default {};

    @AliasFor(
        annotation = ComponentScan.class,
        attribute = "basePackageClasses"
    )
    Class<?>[] scanBasePackageClasses() default {};
}

```

## 2.SpringApplication分析

```java
//基于springBoot1.5.15的源码
public class SpringApplication {
    /**
    *从ApplicationBootstrap的main方法启动会到这个方法
    * 1.先调用SpringApplication的构造方法
    */
    public static ConfigurableApplicationContext run(Object[] sources, String[] args) {
        return new SpringApplication(sources).run(args);
    }
    //SpringApplication的构造方法
    public SpringApplication(Object... sources) {
        initialize(sources);
    }
    private void initialize(Object[] sources) {
        if (sources != null && sources.length > 0) {
            this.sources.addAll(Arrays.asList(sources));
        }
        //判断是不是web项目
        //springBoot2.0以上这里做了修改增加了判断WebFlux
        this.webEnvironment = deduceWebEnvironment();
        //设置初始化器，读取spring.factories文件key ApplicationContextInitializer对应的value并实例化
        //ApplicationContextInitializer接口用于在Spring上下文被刷新之前进行初始化的操作
        setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));
        //设置监听器，读取spring.factories文件key ApplicationListener对应的value并实例化
        setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));
        //没啥特别作用，仅用于获取入口类class对象
        this.mainApplicationClass = deduceMainApplicationClass();
    }
    
    public void setInitializers(
			Collection<? extends ApplicationContextInitializer<?>> initializers) {
		this.initializers = new ArrayList<ApplicationContextInitializer<?>>();
		this.initializers.addAll(initializers);
	}
}
```

### 1.初始化SpringApplication时,在构造函数中调用 `initialize`方法

```java

```



SpringFactoriesLoader.loadFactoryNames(type, classLoader) 方法解析 : 

```java
public class SpringApplication {

  private <T> Collection<? extends T> getSpringFactoriesInstances(Class<T> type,
			Class<?>[] parameterTypes, Object... args) {
		ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
		// Use names and ensure unique to protect against duplicates
		Set<String> names = new LinkedHashSet<String>(
				SpringFactoriesLoader.loadFactoryNames(type, classLoader));
		List<T> instances = createSpringFactoriesInstances(type, parameterTypes,
				classLoader, args, names);
		AnnotationAwareOrderComparator.sort(instances);
		return instances;
	}
    
    private <T> List<T> createSpringFactoriesInstances(Class<T> type,
			Class<?>[] parameterTypes, ClassLoader classLoader, Object[] args,
			Set<String> names) {
		List<T> instances = new ArrayList<T>(names.size());
        //遍历 names集合
		for (String name : names) {
			try {
                //根据 类的全限定名获取 Class 对象
				Class<?> instanceClass = ClassUtils.forName(name, classLoader);
				Assert.isAssignable(type, instanceClass);
                //根据 Class对象获取构造函数
				Constructor<?> constructor = instanceClass
						.getDeclaredConstructor(parameterTypes);
                //创建实例
				T instance = (T) BeanUtils.instantiateClass(constructor, args);
                //加入到集合中
				instances.add(instance);
			}
			catch (Throwable ex) {
				throw new IllegalArgumentException(
						"Cannot instantiate " + type + " : " + name, ex);
			}
		}
		return instances;
	}
}
```

`org.springframework.core.io.support.SpringFactoriesLoader`代码:

```java

// factoryClass = ApplicationContextInitializer.class
// classLoader 是当前线程的 classLoader
public static List<String> loadFactoryNames(Class<?> factoryClass, ClassLoader classLoader) {
		String factoryClassName = factoryClass.getName();
		try {
            //这里会加载classPath下所有包的 META-INF/spring.factories 文件
			Enumeration<URL> urls = (classLoader != null ? classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :
					ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));
			List<String> result = new ArrayList<String>();
			while (urls.hasMoreElements()) {
				URL url = urls.nextElement();
                //读取 spring.factories 
				Properties properties = PropertiesLoaderUtils.loadProperties(new UrlResource(url));
                //获取 key 为 factoryClassName的属性
				String factoryClassNames = properties.getProperty(factoryClassName);
               //将string 转化成list加入到集合中	
                      result.addAll(Arrays.asList(StringUtils.commaDelimitedListToStringArray(factoryClassNames)));
			}
            //返回集合 
			return result;
		}
		catch (IOException ex) {
			throw new IllegalArgumentException("Unable to load [" + factoryClass.getName() +
					"] factories from location [" + FACTORIES_RESOURCE_LOCATION + "]", ex);
		}
	}

// result 结果
//spring-boot-stater包下的spring.factories
org.springframework.context.ApplicationContextInitializer=\
org.springframework.boot.context.ConfigurationWarningsApplicationContextInitializer,\
org.springframework.boot.context.ContextIdApplicationContextInitializer,\
org.springframework.boot.context.config.DelegatingApplicationContextInitializer,\
org.springframework.boot.context.embedded.ServerPortInfoApplicationContextInitializer
//spring-boot-autoconfigure包下的spring.factories
org.springframework.context.ApplicationContextInitializer=\
org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer,\
org.springframework.boot.autoconfigure.logging.AutoConfigurationReportLoggingInitializer
```





## 3.SpringApplication的run方法

```java

    public ConfigurableApplicationContext run(String... args) {
        //计时器
        StopWatch stopWatch = new StopWatch();
        stopWatch.start();
        ConfigurableApplicationContext context = null;
        Collection<SpringBootExceptionReporter> exceptionReporters = new ArrayList<>();
        //设置java.awt.headless系统属性为true，Headless模式是系统的一种配置模式。
        // 在该模式下，系统缺少了显示设备、键盘或鼠标。但是服务器生成的数据需要提供给显示设备等使用。
        // 因此使用headless模式，一般是在程序开始激活headless模式，告诉程序，现在你要工作在Headless        mode下，依靠系统的计算能力模拟出这些特性来
        configureHeadlessProperty();
        //获取监听器集合对象
        SpringApplicationRunListeners listeners = getRunListeners(args);
        //发出开始执行的事件
        listeners.starting();
        try {
            //根据main函数传入的参数，创建DefaultApplicationArguments对象
            ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);
             //根据扫描到的监听器对象和函数传入参数，进行环境准备。
            ConfigurableEnvironment environment = prepareEnvironment(listeners,applicationArguments);
            configureIgnoreBeanInfo(environment);
            Banner printedBanner = printBanner(environment);
            context = createApplicationContext();
            //和上面套路一样，读取spring.factories文件key SpringBootExceptionReporter对应的value
            exceptionReporters = getSpringFactoriesInstances(
                    SpringBootExceptionReporter.class,
                    new Class[] { ConfigurableApplicationContext.class }, context);
            prepareContext(context, environment, listeners, applicationArguments,printedBanner);
            refreshContext(context);
            afterRefresh(context, applicationArguments);
            stopWatch.stop();
            if (this.logStartupInfo) {
                new StartupInfoLogger(this.mainApplicationClass)
                        .logStarted(getApplicationLog(), stopWatch);
            }
            listeners.started(context);
            callRunners(context, applicationArguments);
        }
        catch (Throwable ex) {
            handleRunFailure(context, ex, exceptionReporters, listeners);
            throw new IllegalStateException(ex);
        }

        try {
            listeners.running(context);
        }
        catch (Throwable ex) {
            handleRunFailure(context, ex, exceptionReporters, null);
            throw new IllegalStateException(ex);
        }
        return context;
    }

    private ConfigurableEnvironment prepareEnvironment(SpringApplicationRunListeners listeners,ApplicationArguments applicationArguments) {
        // Create and configure the environment
        //web项目返回new StandardServletEnvironment()
        ConfigurableEnvironment environment = getOrCreateEnvironment();
        configureEnvironment(environment, applicationArguments.getSourceArgs());
        //和listeners.starting一样的流程
        listeners.environmentPrepared(environment);

         //上述完成了环境的创建和配置，传入的参数和资源加载到environment

        //绑定环境到SpringApplication
        bindToSpringApplication(environment);
        if (!this.isCustomEnvironment) {
            environment = new EnvironmentConverter(getClassLoader())
                    .convertEnvironmentIfNecessary(environment, deduceEnvironmentClass());
        }
        ConfigurationPropertySources.attach(environment);
        return environment;
    }

    //在实例化context之前，首先需要确定context的类型，这个是根据应用类型确定的。应用类型webApplicationType在构造器已经推断出来了。
    protected ConfigurableApplicationContext createApplicationContext() {
        Class<?> contextClass = this.applicationContextClass;
        if (contextClass == null) {
            try {
                switch (this.webApplicationType) {
                case SERVLET:
                     //应用为servlet类型的web应用
                    contextClass = Class.forName(DEFAULT_SERVLET_WEB_CONTEXT_CLASS);
                    break;
                case REACTIVE:
                    //应用为响应式web应用
                    contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS);
                    break;
                default:
                    //应用为非web类型的应用
                    contextClass = Class.forName(DEFAULT_CONTEXT_CLASS);
                }
            }catch (ClassNotFoundException ex) {
                throw new IllegalStateException(
                        "Unable create a default ApplicationContext, "
                                + "please specify an ApplicationContextClass",
                        ex);
            }
        }
        return (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);
    }

    private void prepareContext(ConfigurableApplicationContext context,
            ConfigurableEnvironment environment, SpringApplicationRunListeners listeners,
            ApplicationArguments applicationArguments, Banner printedBanner) {
        //关联环境
        context.setEnvironment(environment);
        //ApplicationContext预处理，主要配置Bean生成器以及资源加载器
        postProcessApplicationContext(context);
        //调用初始化器，执行initialize方法，前面set的初始化器终于用上了
		applyInitializers(context);
		listeners.contextPrepared(context);
		if (this.logStartupInfo) {
			logStartupInfo(context.getParent() == null);
			logStartupProfileInfo(context);
		}
		// Add boot specific singleton beans
		ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();
		beanFactory.registerSingleton("springApplicationArguments", applicationArguments);
		if (printedBanner != null) {
			beanFactory.registerSingleton("springBootBanner", printedBanner);
		}
		if (beanFactory instanceof DefaultListableBeanFactory) {
			((DefaultListableBeanFactory) beanFactory)
					.setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding);
		}
		// Load the sources
		Set<Object> sources = getAllSources();
		Assert.notEmpty(sources, "Sources must not be empty");
		load(context, sources.toArray(new Object[0]));
		listeners.contextLoaded(context);
	}
```