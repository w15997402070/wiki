# 函数式接口

函数式接口 : 只定义一个抽象方法的接口

```java
public interface Predicate<T>{
    boolean test (T t);
}
//java.util.Comparator
public interface Comparator<T>{
    int compare(T ol,T o2);
}
//java.lang.Runnable
public interface Runnable(
    void run();
}
//java.util.concurrent.Callable
public interface Callable<V>{
Vcal1();
}
```

## Predicate

`java.util.function.Predicate<T>`接口定义了一个名叫test的抽象方法，它接受泛型T对象，并返回一个boolean。

```java
@ FunctionalInterface 
public interface Predicate<T>{
    boolean test(Tt);
}
public static <T> List<T> filter(List<T> list, Predicate<T> p){
    List<T>results=new ArrayList<>(); 
    for(T s: list ){
        if( p. test(s) ){
            results. add(s);
        }
    }
    return results;
}
Predicate<String> nonEmptystringpredicate = (String s) -> !s.isEmpty();
 List<String> nonEmpty = filter(listOfStrings,nonEmptyStringpredicate);
```

## Consumer

`java.uti1.function.Consumer<T>`定义了一个名叫accept的抽象方法，它接受泛型T的对象，没有返回（void）。你如果需要访问类型T的对象，并对其执行某些操作，就可以使用这个接口。

```java
@FunctionalInterface 
public interface Consumer<T>{
    void accept(Tt); 
}
public static <T> void forEach(List<T> list,Consumer<T>c){
    for（T i : list）{
        c.accept（i）；
    }
）

  // Lambda是consumer中accept方法的实现
foreach(
    Arrays.asList（1，2，3，4，5），
 （Integer i）-> System.out.println（i）)；
```

## Function

`java.uti1.function.Function<T，R>`接口定义了一个叫作 app1y 的方法，它接受一个泛型T的对象，并返回一个泛型R的对象。如果你需要定义一个Lambda，将输入对象的信息映射到输出，就可以使用这个接口（比如提取苹果的重量，或把字符串映射为它的长度）。在下面的代码中，我们向你展示如何利用它来创建一个map方法，以将一个string列表映射到包含每个String长度的Integer列表。

```java
@ FunctionalInterface 
public interface Function<T,R>{
    Rapply(Tt);
}
     public static <T,R> List<R> map (List<T> list, Function<T,R> f ){
        List<R> result = new ArrayList<>();
         for( T s : list ){
             result. add(f. apply(s));
        }
         return result;
     }
//[7,2,6]
List<Integer>1= map(
           Arrays. asList("lambdas","in","action"),
           (String s) -> s. length()
);
```

## 函数描述符

函数式接口的抽象方法的签名基本上就是Lambda表达式的签名。我们将这种抽象方法叫作函数描述符。

`
@FunctionalInterface又是怎么回事？  
如果你去看看新的JavaAPI，会发现函数式接口带有@FunctionalInterface的标注（3.4节中会深入研究函数式接口，并会给出一个长长的列表）。这个标注用于表示该接口会设计成一个函数式接口。如果你用@FunctionalInterface定义了一个接口，而它却不是函数式接口的话，编译器将返回一个提示原因的错误。例如，错误消息可能是“Multiple non-overriding abstract methods found in interface Foo”，表明存在多个抽象方法。请注意，@FunctionalInter-
face不是必需的，但对于为此设计的接口而言，使用它是比较好的做法。它就像是eoverride标注表示方法被重写了。
`

