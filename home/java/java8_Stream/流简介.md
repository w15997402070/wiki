# 1. 流

  Java 8中的集合支持一个新的stream方法，它会返回一个流（接口定义在java.util.stream.Stream里）.
  流到底是什么呢？简短的定义就是“从支持数据处理操作的源生成的元素序列”。让我们一步步剖析这个定义。

- 元素序列——就像集合一样，流也提供了一个接口，可以访问特定元素类型的一组有序值。因为集合是数据结构，所以它的主要目的是以特定的时间/空间复杂度存储和访问元素（如ArrayList 与 LinkedList） 。但流的目的在于表达计算，比如你前面见到的filter、 sorted和map。集合讲的是数据，流讲的是计算。我们会在后面几节中详细解释这个思想。

- 源——流会使用一个提供数据的源，如集合、数组或输入/输出资源。 请注意，从有序集合生成流时会保留原有的顺序。由列表生成的流，其元素顺序与列表一致。

- 数据处理操作——流的数据处理功能支持类似于数据库的操作，以及函数式编程语言中的常用操作，如filter、 map、 reduce、 find、 match、 sort等。流操作可以顺序执行，也可并行执行。

  ##此外，流操作有两个重要的特点。

- 流水线——很多流操作本身会返回一个流，这样多个操作就可以链接起来，形成一个大的流水线。这让我们下一章中的一些优化成为可能，如延迟和短路。流水线的操作可以看作对数据源进行数据库式查询。

- 内部迭代——与使用迭代器显式迭代的集合不同，流的迭代操作是在背后进行的。

```java
import static java.util.stream.Collectors.toList;
    List<String> threeHighCaloricDishNames = menu.stream()
          .filter(d -> d.getCalories() > 300)   //从menu获得流（ 菜肴列表）建立操作流水线：首先选出高热量的菜肴
          .map(Dish::getName)   //获取菜名
          .limit(3)    //只选择头三个
          .collect(toList());    //将结果保 存在另一 个List中
System.out.println(threeHighCaloricDishNames);    //结果是[pork, beef,chicken]
```

在本例中，我们先是对menu调用stream方法，由菜单得到一个流。 数据源是菜肴列表（菜单），它给流提供一个元素序列。接下来，对流应用一系列数据处理操作： filter、 map、 limit和collect。除了collect之外，所有这些操作都会返回另一个流，这样它们就可以接成一条流水线，于是就可以看作对源的一个查询。最后， collect操作开始处理流水线，并返回结果（它和别的操作不一样，因为它返回的不是流，在这里是一个List） 。在调用collect之前，没有任何结果产生，实际上根本就没有从menu里选择元素。你可以这么理解：链中的方法调用都在排队等待，直到调collect。

## *流只能遍历一次*

  和迭代器类似,遍历完之后流就被消费掉了.

```java
    List<String> title = Arrays.asList("Java8", "In","Action");
    Stream<String> s = title.stream();
      s.forEach(System.out::println);  //打印标题中的每个单词
      s.forEach(System.out::println);  //java.lang.IllegalStateException:流已被操作或关闭
```

## 值创建流

```java
   Stream<String> stream = Stream. of("Java 8 ","Lambdas","In ","Action");
   stream. map(String :: toUpperCase). forEach(System. out:: println);
   //空流
   Stream<String> emptyStream = Stream. empty();
```

## 有数组创建流

```java
   int [] nums = [1,2,3,4];
   int sum = Arrays.stream(nums).sum();
```

## 文件生成流

Java中用于处理文件等I/O操作的NIO API（非阻塞I/O）已更新，以便利用StreamAPI。
java.nio.file.Files中的很多静态方法都会返回一个流。例如，一个很有用的方法是Files.1ines，它会返回一个由指定文件中的各行构成的字符串流。使用你迄今所学的内容，你可以用这个方法看看一个文件中有多少各不相同的词：

```java
1ong uniquewords = 0；//关闭
try（
    Stream<String>lines =
          Files.lines（Paths.get（"data.txt"），Charset.defaultCharset（）））{ //流会自动关闭
    uniquewords = lines.flatMap（line -> Arrays.stream（line.split（""））） //生成单词流
                       .distinct()//删除重复项
                       .count（）；//数一数有多少各不相同的单词
          }catch（IoException e）{
            //如果打开文件时出
          }
```

## 由函数生成流 : 创建无限流

### Stream.iterate

```java
    Stream.iterate(0, n -> n+2 )
          .limit(10)
          .forEach(System.out :: println);
```

### Stream.generate

与iterate方法类似，generate方法也可让你按需生成一个无限流。但generate不是依次对每个新生成的值应用函数的。它接受一个`supplier<T>`类型的Lambda提供新的值。我们先来看一个简单的用法：

```java
    Stream.generate(Math.random)
          .limit(10)
          .forEach(System.out :: println);
```
