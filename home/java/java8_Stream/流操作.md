# 流操作

## 1. 筛选和切片

### 1.1 用谓词筛选

谓词 : 一个返回boolean的函数

```java
    List<Dish> vegetarianMenu = menu.stream()
                                    .filter(Dish::isVegetarian) //方法引用检查菜肴是否适合素食者
                                    .collect(toList());
```

### 1.2 筛选各异的元素(distinct())

根据流所生成的hashCode和equals方法

```java
    List<Integer> numbers = Arrays.asList(1, 2, 1, 3, 3, 2, 4);
      numbers.stream()
             .filter(i -> i % 2 == 0)
             .distinct()
             .forEach(System.out::println);
```

### 1.3 截短流(limit())

```java
  List<Dish> dishes = menu.stream()
                          .filter(d -> d.getCalories() > 300)
                          .limit(3)
                          .collect(toList());
```

### 1.4 跳过元素(skip(n))

流还支持skip(n)方法，返回一个扔掉了前n个元素的流。如果流中元素不足n个，则返回一
个空流。请注意， limit(n)和skip(n)是互补的！

```java
  List<Dish> dishes = menu.stream()
                          .filter(d -> d.getCalories() > 300)
                          .skip(2)
                          .collect(toList());
```

## 2.映射

### 2.1 对流中每一个元素应用函数

流支持map方法，它会接受一个函数作为参数。这个函数会被应用到每个元素上，并将其映
射成一个新的元素（使用映射一词，是因为它和转换类似，但其中的细微差别在于它是“创建一
个新版本”而不是去“修改”）

```java
//例如，下面的代码把方法引用Dish::getName传给了map方法，来提取流中菜肴的名称：
  List<String> dishNames = menu.stream()
                               .map(Dish::getName)
                               .collect(toList());

  List<String> words = Arrays.asList("Java 8", "Lambdas", "In", "Action");
  List<Integer> wordLengths = words.stream()
                                   .map(String::length)
                                   .collect(toList());

```

### 2.2 流的扁平化

//例 如 ， 给 定 单 词 列 表["Hello","World"]，你想要返回列表["H","e","l", "o","W","r","d"]

1. 尝试使用map和Arrays.stream()

```java
  //  String[] arrayOfWords = {"Goodbye", "World"};
  //  Stream<String> streamOfwords = Arrays.stream(arrayOfWords);
        words.stream()
             .map(word -> word.split(""))  //将每个单词转换为由其字母构成的数组
             .map(Arrays::stream)  //让每个数组变成一个单独的流
             .distinct()
             .collect(toList());
  当前的解决方案仍然搞不定！这是因为，你现在得到的是一个流的列表（更准确地说是
   Stream<String>） ！的确，你先是把每个单词转换成一个字母数组，然后把每个数组变成了一个独立的流
```

2. 使用flatMap

```java
    List<String> uniqueCharacters = words.stream()
           .map(w -> w.split(""))
           .flatMap(Arrays::stream)
           .distinct()
           .collect(Collectors.toList());
```

使用flatMap方法的效果是，各个数组并不是分别映射成一个流，而是映射成流的内容。所有使用map(Arrays::stream)时生成的单个流都被合并起来，即扁平化为一个流。

flatmap方法让你把一个流中的每个值都换成另一个流，然后把所有的流连接
起来成为一个流

3. 使用两个流

给定两个数字列表，如何返回所有的数对呢？例如，给定列表[1，2，3]和列表[3，4]，应该返回[（1，3），（1，4），（2，3），（2，4），（3，3），（3，4）]。为简单起见，你可以用有两个元素的数组来代表数对。
答案：你可以使用两个map来迭代这两个列表，并生成数对。但这样会返回一个Stream-<Stream<Integer[]>>。你需要让生成的流扁平化，以得到一个Stream<Integer[]>。这正是flatMap所做的：

```java
List<Integer> numbersl = Arrays.asList（1，2，3）；
List<Integer> numbers2 = Arrays.asList（3，4）；
List<int[]> pairs = numbers1.stream（）
                            .flatMap（i -> numbers2.stream（）.map（j -> new int[]{i，j}）
                            .collect（toList（））；
```

## 3.查找和匹配

### 3.1 检查谓词是否至少匹配一个元素

anyMatch方法可以回答“流中是否有一个元素能匹配给定的谓词”。比如，你可以用它来看
看菜单里面是否有素食可选择：

```java
  if(menu.stream().anyMatch(Dish::isVegetarian)){
      System.out.println("The menu is (somewhat) vegetarian friendly!!");
  }
```

anyMatch方法返回一个boolean，因此是一个终端操作。

### 3.2 检查谓词是否匹配所有元素

allMatch方法的工作原理和anyMatch类似，但它会看看流中的元素是否都能匹配给定的谓
词。比如，你可以用它来看看菜品是否有利健康（即所有菜的热量都低于1000卡路里）.

```java
  boolean isHealthy = menu.stream()
                          .allMatch(d -> d.getCalories() < 1000);
```

noneMatch  
和allMatch相对的是noneMatch。它可以确保流中没有任何元素与给定的谓词匹配。
你可以用noneMatch重写前面的例子：

```java
  boolean isHealthy = menu.stream()
                          .noneMatch(d -> d.getCalories() >= 1000);
```

### 3.3 查找元素

findAny方法将返回当前流中的任意元素。它可以与其他流操作结合使用。比如，你可能想
找到一道素食菜肴。你可以结合使用filter和findAny方法来实现这个查询：

```java
    Optional<Dish> dish = menu.stream()
                              .filter(Dish::isVegetarian)
                              .findAny();
```

### 3.4 查找第一个元素

有些流有一个出现顺序（encounter order）来指定流中项目出现的逻辑顺序（比如由List或
排序好的数据列生成的流）。对于这种流，你可能想要找到第一个元素。为此有一个findFirst
方法，它的工作方式类似于findany。

```java
例如，给定一个数字列表，下面的代码能找出第一个平方能被3整除的数：
    List<Integer> someNumbers = Arrays.asList(1, 2, 3, 4, 5);
        Optional<Integer> firstSquareDivisibleByThree = someNumbers.stream()
                  .map(x ->x * x)
                  .filter(x -> x % 3 == 0)
                  .findFirst(); // 9
```

*何时使用findFirst和findAny你可能会想，为什么会同时有findFirst和findAny呢？答案是并行。找到第一个元素在并行上限制更多。如果你不关心返回的元素是哪个，请使用findAny，因为它在使用并行流时限制较少。*

## 4. 规约

### 4.1 元素求和

```java
    List<Integer> someNumbers = Arrays.asList(1, 2, 3, 4, 5);
    int sum = list.stream().reduce(0,(a,b) -> a+b);
    int sum = list.stream().reduce(0,Integer::sum);//和上面的效果一样
   Optional<Integer> sum = list.stream().reduce(Integer::sum);//不接受初始值,但是返回Optional<Integer>,因为流中没有任何元素,reduce操作无法返回和,包裹在Optional<T>对象里面表明可能不存在
```

reduce接收两个参数 :

- 一个初始值,这里是0; 
- 一个 `BinaryOperator<T>`来将两个元素结合起来产生一个新值,这里我们用的是lambda (a,b) -> a + b;

### 4.2 最大值和最小值

```java
    //查询最大值
    Optional<Integer> sum2 = list.stream().reduce(Integer::max);
    //最小值  这里也可以写成 (x,y) -> x < y ? x : y;
    Optional<Integer> sum3 = list.stream().reduce(Integer::min);

```

![流操作](流操作.png)

### 原始类型流特化

1. 映射到数值流

```java
    int calories = menu.stream()   //返回一个Stream<Dish>
                       .mapToInt(Dish :: getCalories) //返回一个IntStream
                       .sum();//这里还可以max,min,average等
/*求和的那个例子很容易，因为它有一个默认值：0。但是，如果你要计算Intstream中的最大元素，就得换个法子了，因为0是错误的结果。如何区分没有元素的流和最大值真的是0的流呢？
前面我们介绍了optional类，这是一个可以表示值存在或不存在的容器。optional可以用Integer、String等参考类型来参数化。对于三种原始流特化，也分别有一个optional原始类型特化版本：OptionalInt、OptionalDouble和optionalLong。*/
    OptionalInt maxCalories = menu.stream()   //返回一个Stream<Dish>
                       .mapToInt(Dish :: getCalories) //返回一个IntStream
                       .max();
    //如果没有最大值,可以显示处理OptionalInt去定义一个默认值
    int max = maxCalories.orElse(1);
    //将Stream转换为数值流
    IntStream  intStream = menu.stream().mapToInt(Dish :: getCalories);
    //将数值流转换为Stream
    Stream<Integer> stream = intStream.boxed();
```

2. 数值范围

生成1到100的所有数字可以使用 IntStream 和 LongStream 的静态方法,range 和 rangeClosed,这两个方法都是第一个参数接受起始值,第二个参数接受结束值,但是 range 不包含结束值,rangeClosed 包含结束值

```java
  IntStream  evenNumbers = IntStream.rangeClosed(1,100) //表示范围从1到100
                                    .filter(n -> n % 2 == 0);//取偶数
  int count = eventNumbers.count();//会有50个偶数
  //如果用range(1,99) 则只有49个偶数

```

## 流收集数据操作

### 规约和汇总

```java
import static java.util.stream.Collectors.*;

long howmanyDishes = menu.stream().collect(Collectors.counting());
//或者
long howmanyDishes = menu.stream().count();
```

### 查找流中最大值和最小值

```java
Comparator<Dish> dishCaloriesComparator =
Comparator.comparingInt(Dish:: getCalories);
Optional<Dish> mostcalorieDish =
menu.stream().collect(maxBy(dishCaloriesComparator));
```

### 汇总

```java
//求和 Collectors.summingLong 和 Collectors.summingDouble方法作用一样
int totalCalories = menu.stream().collect(summingInt(Dish:: getCalories));

//求平均数 Collectors.averagingDouble 和 Collectors.averagingLong
double avgcalories = menu.stream().collect(averagingInt(Dish:: getCalories));
```

### 连接字符串

```java
//拼接字符串
String shortMenu = menu.stream().map(Dish:: getName).collect(joining());
//带连接符
string shortMenu = menu.stream().map(Dish:: getName).collect(joining(","));
```

### 综合方法

```java
int totalCalories = menu.stream（）.collect（reducing（
                                            0，Dish:：getCalories，（i，j）->i+j））；
//它需要三个参数。
//1.第一个参数是归约操作的起始值，也是流中没有元素时的返回值，所以很显然对于数值和而言0是一个合适的值。
//2.第二个参数就是你在6.2.2节中使用的函数，将菜肴转换成一个表示其所含热量的int。
//3.第三个参数是一个Binaryoperator，将两个项目累积成一个同类型的值。这里它就是对两个int求和。
```

### 分组

```java
//Collectors.groupingBy()
Map<Dish.Type,List<Dish>> dishesByType =menu.stream().collect(groupingBy(Dish::getType));

public enum CaloricLevel { DIET, NORMAL, FAT}
Map<CaloricLevel, List<Dish>> dishesByCaloricLevel =
                         menu.stream().collect(
                         groupingBy(dish->{
                                  if(dish. getCalories()<=400) return CaloricLevel. DIET;
                                  else if (dish. getCalories()<=700) return CaloricLeve1. NORMAL;
                                  else return CaloricLevel. FAT;
                                  }
                                  )
                          );


Map<Dish.Type,Long> typesCount = menu.stream().collect(groupingBy(Dish::getType,counting()));
//结果  {MEAT=3,FISH=2,OTHER=4}
```

### 多级分组

```java
Map<Dish.Type，Map<CaloricLevel，List<Dish>>> dishesByTypeCaloricLevel =
              menu.stream（）.collect（
                     groupingBy（Dish:：getType，
                             groupingBy（dish->{
                               if（dish.getcalories（）<= 400）return CaloricLevel.DIET；
                               else if（dish.getCalories（）<=700）return CaloricLevel.NORMAL；
                               else return CaloricLevel. FAT;
                               }
                             )
                     );

//把收集器转换成另一种类型
Map<Dish.Type，Dish> mostCaloricByType =
menu.stream（）
    .collect（groupingBy（Dish:：getType，
                         collectingAndThen（
                             maxBy（comparingInt（Dish:：getcalories）），
                             Doptional:：get）））；
```

### 分区

```java
Map<Boolean，List<Dish>> partitionedMenu =  menu.stream（）.collect（partitioningBy（Dish::isVegetarian））；
//这会返回下面的Map：
{false=[pork，beef，chicken，prawns，salmon]，true=[french fries，rice，season fruit，pizzal}
//那么通过Map中键为true的值，就可以找出所有的素食菜肴了：
List<Dish> vegetarianpishes = partitionedMenu.get（true）；
```

## Collector接口

```java
public interface Collector<T,A,R>{
           Supplier<A> supplier();
           BiConsumer<A,T> accumulator();
           Function<A,R> finisher();
           BinaryOperator<A> combiner();
           Set<Characteristics> characteristics();
}
```

- T是流中要收集的项目的泛型。
- A是累加器的类型，累加器是在收集过程中用于累积部分结果的对象。
- R是收集操作得到的对象（通常但并不一定是集合）的类型。

![静态方法](Collectors静态工厂方法.png)
![静态方法](静态方法.png)
