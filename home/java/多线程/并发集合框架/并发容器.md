# 并发容器

## 集合框架

* 接口 Iterable的作用就是迭代循环
       iterator() 方法返回 Iterator 对象

* 接口 Collection 提供了集合框架最主要,最常用的操作

  ```
  int size()
  boolean isEmpty()
  boolean contains(Object o)
  boolean containsAll(Collection<?> c)
  Iterator<E> iterator()
  Object[] toArray()
  <T> T[] toArray(T[] a)
  boolean add(E e)
  boolean addAll(Collection<? extends E> c);
  boolean remove(Object o)
  boolean removeAll(Collection<?> c)
  boolean retainAll(Collection<?> c) 判断是否存在交集
  void clear()
  
  default boolean removeIf(Predicate<? super E> filter)
  default Spliterator<E> spliterator() 
  default Stream<E> stream()
  default Stream<E> parallelStream()
  ```

* 接口List 对 Collection接口进行了扩展,允许根据索引位置操作数据,并且内容允许重复.

  * ArrayList 线程不安全
  * Vector 线程安全
  * Vector有一个子类Stack ,可以实现后进先出(LIFO) 的对象堆栈

* 接口Set 内容不允许重复,排序方式为自然排序

  * HashSet 线程不安全
  * LinkedHashSet 可以有序的组织元素
  * TreeSet

* 接口Queue 可以方便地操作列头

  * PriorityQueue 一个基于优先级的无界优先级队列

* 接口 Deque 可以支持对表头的操作,而且还支持对表尾的操作,全称为 " double ended queue (双端队列)"

  * ArrayDeque
  * LinkedList

  

retainAll() 会移除掉集合中的不相同的元素 : 

```java
@org.junit.Test
    public void retainAllTest(){
        List<String> oriList = new ArrayList<>();
        oriList.add("1");
        oriList.add("2");
        oriList.add("3");
        List<String> compareList = Arrays.asList("1", "4","5");
        boolean b = oriList.retainAll(compareList);
        logger.info("结果 : "+b);//结果 : true
        logger.info("list1 : {}",JSON.toJSONString(oriList));//list1 : ["1"],把集合中的其他元素移除了,这里如果是Arrays.asList("1", "2","3"); 会报java.lang.UnsupportedOperationException 异常
        logger.info("list2 : {}",JSON.toJSONString(compareList));//list2 : ["1","4","5"]
    }
```

## 非阻塞队列

非阻塞队列的特色就是队列里面没有数据时,操作队列出现异常或返回null,不具有等待/阻塞的特色

```
ConcurrentHashMap
ConcurrentSkipListMap 支持排序
ConcurrentSkipListSet 支持排序且不允许重复元素
ConcurrentLinkedQueue 并发环境的队列操作
    poll() 没有获得数据时返回null,有数据时则移除表头,并将表头返回
    element() 没有数据时出现NoSuchElementExeception
    peek() 当没有数据时返回null,有数据时不移除表头,并将表头返回
ConcurrentLinkedDeque 支持对列头列尾双向操作
CopyOnWriteArrayList
CopyOnWriteArraySet
```

## 阻塞队列

在JDK中提供了若干集合工具类都具有阻塞特性，所谓的阻塞队列 `BlockingQueue`，其实就是如果`BlockQueue`是空的，从`BlockingQueue`取东西的操作将会被阻塞进人等待状态，直到`BlockingQueue`添加进了元素才会被唤醒。同样，如果`BlockingQueue`是满的，也就是没有空余空间时，试图往队列中存放元素的操作也会被阻塞进入等待状态，直到`BlockingQueue`里有剩余空间才会被唤醒继续操作。

```
ArrayBlockingQueue 有界阻塞队列
LinkedBlockingQueue 无界阻塞队列 也可以定义成有界的
LinkedBlockingDeque 提供对双端终点的操作
SynchronousQueue 类SynchronousQueue为异步队列。
一种阻塞队列，其中每个插入操作必须等待另一个线程的对应移除操作，反之亦然。同步队列没有任何内部容量，甚至连一个队列的容量都没有。不能在同步队列上进行peek，因为仅在试图要移除元素时，该元素才存在；除非另一个线程试图移除某个元素，否则也不能（使用任何方法）插入元素；也不能迭代队列，因为其中没有元素可用于迭代。类SynchronousQueue经常在多个线程之间传输数据时使用。
LinkedTransferQueue 提供的功能与
DelayQueue 延时执行的队列SynchronousQueue有些类似,但其具有嗅探功能,也就是可以尝试性的添加一些数据
    take() 具有阻塞特性
    transfer() 1.如果当前存在一个正在等待获取值的消费者线程,则把数据立即传输过去
               2.否则会将元素插入到队列的尾部,并且进入阻塞状态,直到有消费者线程取走该元素
    tryTransfer（e）的作用为：
               1）如果当前存在一个正在等待获取的消费者线程，使用try-Transfer（e）方法会立即传输数据；
               2）否则，如果不存在，则返回false，并且数据不放入队列中，执行的效果是不阻塞的。
PriorityBlockingQueue 支持在并发条件下的优先级队列

```