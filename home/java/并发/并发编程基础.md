
# 并发编程基础

[toc]

## 进程和线程

### 什么是线程

### 共享资源

共享资源就是该资源被多个线程所持有或者说多个线程都可以去访问该资源

### 线程安全问题

指当多个线程同时读写一个共享资源并且没有任何同步措施时,导致出现脏数据或者其他不可预见结果的问题

### 内存模型图示

文档：java内存模型-计算机工作内存.png
链接：<http://note.youdao.com/noteshare?id=da5232cd80c1a56d77344bdcacd2f91b&sub=12D3A449367649DB898A5DEA9B9A6CA2>

Java内存模型规定，将所有的变量都存放在主内存中，当线程使用变量时，会把主内存里面的变量复制到自己的工作空间或者叫作工作内存，线程读写变量时操作的是自己工作内存中的变量。

计算机工作内存图中所示是一个双核CPU系统架构，每个核有自己的控制器和运算器，其中控制器包含一组寄存器和操作控制器，运算器执行算术逻辑运算。每个核都有自己的一级缓存，在有些架构里面还有一个所有CPU都共享的二级缓存。那么Java内存模型里面的工作内存，就对应这里的L1或者L2缓存或者CPU的寄存器。当一个线程操作共享变量时，它首先从主内存复制共享变量到自己的工作内存，然后对工作内存里的变量进行处理，处理完后将变量值更新到主内存

### 内存可见性

java内存模型规定将所有的变量都存放在主内存中,当线程使用变量时,会把主内存里面的变量复制到自己的工作空间或者叫工作内存,线程读写变量时操作是自己工作内存的变量

### Java指令重排序

Java内存模型允许编译器和处理器对指令重排序以提高运行性能，并且只会对不存在数据依赖性的指令重排序。在单线程下重排序可以保证最终执行的结果与程序顺序执行的结果一致，但是在多线程下就会存在问题。
重排序在多线程下会导致非预期的程序执行结果，而使用volatile修饰ready就可以避免重排序和内存可见性问题。写volatile变量时，可以确保volatile写之前的操作不会被编译器重排序到volatile写之后。读volatile变量时，可以确保volatile读之后的操作不会被编译器重排序到volatile读之前。

### 伪共享

在JDK 8之前一般都是通过字节填充的方式来避免该问题
也就是创建一个变量时使用填充字段填充该变量所在的缓存行，这样就避免了将多个变量存放在同一个缓存行中

```java
public final static class FilledLong {
   public volatile long value = 0L;
   public long p1, p2, p3, p4, p5, p6;
}
```

JDK 8提供了一个sun.misc.Contended注解，用来解决伪共享问题。
将上面代码修改为如下。

```java
@Contended
public final static class FilledLong {
   public volatile long value = 0L;
}
```

### wait() 和 notify()

wait（）的时候必须释放锁?

## 问题

thread.join() 方法 ?

join()方法在start()之前还是之后?

join()实现源码?

### 线程之间如何通信

通信指线程之间以何种机制来交换信息

* 共享内存 : 在共享内存的并发模型里,线程之间共享程序的公共状态,线程之间通过写-读内存中的公共状态来隐式进行通信
* 消息传递 : 在消息传递的并发模型里,线程之间没有公共状态,线程之间必须通过明确的发送消息来显示进行通信

### 缓存不一致问题

MESI协议 : 当CPU写数据时,如果发现操作的变量是共享变量(即其他CPU上也存在该变量),就发出信号通知其他CPU将它高速缓存中这个变量缓存行置为无效状态,因此当其它CPU需要读取这个变量时,发现自己高速缓存中缓存变量的缓存行为无效状态,那么它就从主存中重新读取

### 处理器重排序问题

## 并发和并行

* 并发指一个时间段内多个任务同时执行,并且都没有执行结束.并发任务强调在一个时间段内同时执行,而一个时间段由多个单位时间累积而成,所以说并发的多个任务在单位时间内不一定同时执行
* 并行指在单位时间内多个任务同时在执行

*

=======

# 并发编程基础

[toc]

## 进程和线程

### 什么是线程

### 共享资源

共享资源就是该资源被多个线程所持有或者说多个线程都可以去访问该资源

### 线程安全问题

指当多个线程同时读写一个共享资源并且没有任何同步措施时,导致出现脏数据或者其他不可预见结果的问题

### 内存可见性

java内存模型规定将所有的变量都存放在主内存中,当线程使用变量时,会把主内存里面的变量复制到自己的工作空间或者叫工作内存,线程读写变量时操作是自己工作内存的变量

## 问题

thread.join() 方法 ?

join()方法在start()之前还是之后?

join()实现源码?

### 线程之间如何通信

通信指线程之间以何种机制来交换信息

* 共享内存 : 在共享内存的并发模型里,线程之间共享程序的公共状态,线程之间通过写-读内存中的公共状态来隐式进行通信
* 消息传递 : 在消息传递的并发模型里,线程之间没有公共状态,线程之间必须通过明确的发送消息来显示进行通信

### 缓存不一致问题

MESI协议 : 当CPU写数据时,如果发现操作的变量是共享变量(即其他CPU上也存在该变量),就发出信号通知其他CPU将它高速缓存中这个变量缓存行置为无效状态,因此当其它CPU需要读取这个变量时,发现自己高速缓存中缓存变量的缓存行为无效状态,那么它就从主存中重新读取

### 处理器重排序问题

## 并发和并行

* 并发指一个时间段内多个任务同时执行,并且都没有执行结束.并发任务强调在一个时间段内同时执行,而一个时间段由多个单位时间累积而成,所以说并发的多个任务在单位时间内不一定同时执行
* 并行指在单位时间内多个任务同时在执行

*

单CPU时代都是并发执行,因为一个任务占用CPu运行时,其他任务会被挂起,占用CPU的任务时间片用完后,会把CPU让给其他任务来使用.所以单CPU时代多线程编程是没有太大意义的,并且线程间频繁的上下文切换还会带来额外开销
