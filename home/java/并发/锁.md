
# 锁概念

[toc]

## 乐观锁与悲观锁

* 悲观锁 : 指对数据被外界修改持保守状态,认为数据很容易就会被其他线程修改,所以在数据被处理前先对数据进行加锁,并在整个数据处理过程中,使数据处于锁定状态.

悲观锁的实现往往依赖数据库提供的锁机制,即在数据库中,在对数据记录操作前给记录加排它锁.如果获取锁失败,则说明数据正在被其他线程修改,当前线程等待或者抛出异常.如果获取锁成功,则对记录进行操作,然后提交事务后释放排它锁.

* 乐观锁 : 乐观锁是相对悲观锁来说的,它认为数据在一般情况下不会造成冲突,所以在访问记录前不会加排他锁,而是在进行数据提交更新时,才会正式对数据冲突与否进行检测

## 公平锁与非公平锁

* 公平锁 : 表示线程获取锁的顺序是按照请求锁的时间早晚来决定的,也就是最早请求锁的线程最早获取到锁.
* 非公平锁 : 则在运行时闯入,也就是先来不一定先得

在没有公平性需求的前提下尽量使用非公平锁,因为公平锁会带来性能开销

## 独占锁与共享锁

* 独占锁 : 保证任何时候都只有一个线程能得到锁,例如ReentrantLock
* 共享锁 : 可以同时由多个线程持有,例如 : ReadWriteLock

## 可重入锁

当一个线程再次获取它自己已经获取的锁时不被阻塞,也就是只要该线程获取了该锁,那么可以无限次(严格来说是有限次数)地进入被该锁锁住的代码

## 自旋锁

自旋锁 : 当前线程在获取锁时如果发现锁已经被其他线程占有,它不马上阻塞自己,在不放弃CPU使用权的情况下,多次尝试获取,很有可能在后面几次尝试中其他线程已经释放了锁.如果尝试指定的次数后仍没有获取到锁则当前线程才会被阻塞挂起
=======

# 锁

[toc]

## 乐观锁与悲观锁

* 悲观锁 : 指对数据被外界修改持保守状态,认为数据很容易就会被其他线程修改,所以在数据被处理前先对数据进行加锁,并在整个数据处理过程中,使数据处于锁定状态.

悲观锁的实现往往依赖数据库提供的锁机制,即在数据库中,在对数据记录操作前给记录加排它锁.如果获取锁失败,则说明数据正在被其他线程修改,当前线程等待或者抛出异常.如果获取锁成功,则对记录进行操作,然后提交事务后释放排它锁.

* 乐观锁 : 乐观锁是相对悲观锁来说的,它认为数据在一般情况下不会造成冲突,所以在访问记录前不会加排他锁,而是在进行数据提交更新时,才会正式对数据冲突与否进行检测

## 公平锁与非公平锁

* 公平锁 : 表示线程获取锁的顺序是按照请求锁的时间早晚来决定的,也就是最早请求锁的线程最早获取到锁.
* 非公平锁 : 则在运行时闯入,也就是先来不一定先得

在没有公平性需求的前提下尽量使用非公平锁,因为公平锁会带来性能开销

## 独占锁与共享锁

* 独占锁 : 保证任何时候都只有一个线程能得到锁,例如ReentrantLock
* 共享锁 : 可以同时由多个线程持有,例如 : ReadWriteLock

## 可重入锁

当一个线程再次获取它自己已经获取的锁时不被阻塞,也就是只要该线程获取了该锁,那么可以无限次(严格来说是有限次数)地进入被该锁锁住的代码

## 自旋锁

自旋锁 : 当前线程在获取锁时如果发现锁已经被其他线程占有,它不马上阻塞自己,在不放弃CPU使用权的情况下,多次尝试获取,很有可能在后面几次尝试中其他线程已经释放了锁.如果尝试指定的次数后仍没有获取到锁则当前线程才会被阻塞挂起
