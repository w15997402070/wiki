# 企业级高并发

```
QPS(Query Per Second)意思为“每秒查询率”，是一台服务器每秒能够响应的查询次数，是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准.  
QPS = 总请求数 / ( 进程总数 *   请求时间 )
```

## 1 . 50QPS一下 -- 小网站

简单的小网站,最简单的方法搭建,短期没有太多的技术瓶颈,只要服务器不要太烂就好.

## 2 . QPS达到100(DB极限型)(200-700)

假设关系型数据库的每次请求在0.01秒完成  
假设单页面只有一个SQL查询,那么100QPS意味着这1秒钟完成100次请求,但是此时我们并不能保证数据库查询能完成1000次'
解决方案 : 数据库缓存层,数据库的负载均衡

## 3 . QPS达到800[带宽极限型](100M带宽)

假设我们使用百兆宽带,意味着网站出口的实际带宽是8M左右  
假设每个页面只有10k,这个并发条件下百兆带宽已经吃完  

解决方案 : CDN加速,负载均衡LVS -> Nginx,镜像  
访问页面是否存在动态资源和静态资源 -> 动静分离
                    图片最吃带宽 -> 搞一个图片服务器

## 4. QPS达到1000(内网宽带极限+Memcache极限型)

(12306,刷新频繁,出现验证码;知乎,登陆间隔时间0.5秒,出现验证码)
[redis:5w;Memcache:10w]  
假设使用Memcache缓存数据库查询数据,每个页面对Memcache的请求远大于直接对DB的请求  
Memcache的悲观并发数在2w左右,但有可能在此之前带宽已经吃光,表现出不稳定  
数据库缓存,数据库集群(读写分离,分片,分库,分表),数据库负载均衡,动静分离,线程池可以限流  
解决方案 : 静态html缓存  
非静态化 : 请求 -> web服务器 -> Servlet -> 业务逻辑层 -> 数据访问层 -> 响应数据 -> 渲染动态页面  
静态化 : 请求 -> web页面 -> Servlet -> 页面静态化(freemaker,volecity,thymeleaf) -> 渲染出来  
为了保证数据安全,使用锁机制来保护数据访问

## 5 . QPS达到2000(锁机制极限型) -> (上市公司)

这个级别下,文件系统访问锁成为灾难  
解决方案 : 业务分离,分布式存储[并行化编程,无锁化编程]







