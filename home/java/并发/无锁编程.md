# 无锁编程的场景

[toc]

## 一写一读的无锁队列：内存屏障
一写一读的无锁队列即Linux内核的kfifo队列，一写一读两个线程，不需要锁，只需要内存屏障。

## 一写多读的无锁队列：volatile关键字

Disruptor是一个开源的并发框架，能够在无锁的情况下实现Queue并发操作

Disruptor的RingBuffer之所以可以做到完全无锁，也是因为“单线程写”，这是“前提的前提”。离开了这个前提条件，没有任何技术可以做到完全无锁。借用Disruptor官方提到的一篇博客文章Sharing Data Among Threads Without Contention，也就是single-writerprinciple。在这个原则下，利用volatile 关键字可以实现一写多读的线程安全。具体来说，就是RingBuffer有一个头指针，对应一个生产者线程；多个尾指针对应多个消费者线程。每个消费者线程只会操作自己的尾指针。所有这些指针的类型都是volatile变量，通过头指针和尾指针的比较，判断队列是否为空。

## 多写多读的无锁队列：CAS

基于CAS和链表，可以实现一个多写多读的队列。具体来说，就是链表有一个头指针head和尾指针tail。入队列，通过对tail进行CAS操作完成；出队列，对head进行CAS操作完成。

## CAS和传统的同步,可以使用如下的指导原则

* 如果访问的是不存在竞争的资源，那么基于CAS的保护要稍快于传统的同步（虽然完全不使用保护会更快）。
* 如果访问的资源存在轻度或适度的竞争，那么基于CAS的保护要快于传统的同步（而且往往是快得多）。
* 随着所访问资源的竞争越来越剧烈，在某一时刻，传统的同步就会成为更高效的选择。在实践中，这只会出现在运行着大量线程的非常大型的机器上。
* 当被保护的值有多个读取，但不会被写入时，基于CAS的保护不会受竞争的影响。



## 无锁栈

无锁栈比无锁队列的实现更简单，只需要对head 指针进行CAS 操纵，就能实现多线程的入栈和出栈。

## 无锁链表

相比无锁队列与无锁栈，无锁链表要复杂得多，因为无锁链表要在中间插入和删除元素。