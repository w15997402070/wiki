# 执行器实战

[toc]

## 创建一个线程执行器并实现其拒绝策略

一. 创建一个`Task`类实现`Runnable`接口

```java
//1．实现一个任务并提交执行。创建一个名为Task的类，并实现Runnable接口：
public class Task implements Runnable {
//2.声明一个名为initDate的Date类型的属性来存储任务的创建时间；并声明一个名为name的String类型的属性来存储任务的名称：
    private final Date initDate;
    private final String name;
//3．实现该类的构造方法,并初始化全部属性：
    public Task(String name){
        initDate = new Date();
        this.name = name;
    }
//4．实现run()方法
    @Override
    public void run() {
//5．打印initDate的值和执行当前任务时的真正时间：
        System.out.printf("%s: Task %s Created on: %s\n", Thread.currentThread().getName(), name, initDate);
        System.out.printf("%s: Task %s Started on: %s\n", Thread.currentThread().getName(), name, LocalDateTime.now().toString());
//6．让当前任务随机休眠一段时间：
        try {
            long duration = ThreadLocalRandom.current().nextLong(5);
            System.out.printf("%s: Task %s Doing a task during: %d seconds\n", Thread.currentThread().getName(), name, duration);
            TimeUnit.SECONDS.sleep(duration);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
//7．在控制台打印任务的完成时间：
        System.out.printf("%s: Task %s Finished on: %s\n", Thread.currentThread().getName(), name, LocalDateTime.now().toString());
    }
}
```

二. 创建拒绝策略类

```java
//创建一个名为RejectedTaskController的类，并实现RejectedExecutionHandler接口。在类中实现接口的rejectedExecution()方法，然后打印出被拒绝的任务名称和执行器的名称与状态：
public class RejectedTaskController implements RejectedExecutionHandler {
    @Override
    public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
        System.out.printf("RejectedTaskController: The task %s has been rejected\n", r.toString());
        System.out.printf("RejectedTaskController: %s\n", executor.toString());
        System.out.printf("RejectedTaskController:  Terminating: %s\n", executor.isTerminating());
        System.out.printf("RejectedTaskController:  Terminated: %s\n", executor.isTerminated());
    }
}
```

三. 创建Server类

```java
//9．创建一个Server类，用一个executor实例对象来执行它收到的每一个任务：
public class Server {
//10．声明一个名为executor、类型为ThreadPoolExecutor的属性：
    private final ThreadPoolExecutor executor;
//11．实现这个类的构造方法，用Executors类来初始化ThreadPoolExecutor对象，并创建一个拒绝策略：
    public Server(){
        executor = (ThreadPoolExecutor) Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());
        RejectedTaskController rejectedTaskController = new RejectedTaskController();
        executor.setRejectedExecutionHandler(rejectedTaskController);
    }
//12．实现executeTask()方法来接收一个Task对象作为参数，并将其提交给一个执行器。首先，在控制台打印信息来表明一个新任务已经到达：
    public void executeTask(Task task){
        System.out.printf("Server: A new task has arrived\n");
//13．调用执行器的execute()方法来提交任务：
        executor.execute(task);
//14．在控制台打印执行器的信息来区分状态：
        //• getPoolSize()：该方法返回执行器线程池中当前的线程数。
        //• getActiveCount()：该方法返回执行器中正在执行任务的线程数。
        //• getTaskCount()：该方法返回等待执行的任务数。由于等待执行的任务数是动态变化的，因此该方法返回的只是一个近似值。
        //• getCompletedTaskCount()：该方法返回执行器已经完成的任务数。
        System.out.printf("Server: Pool Size: %d\n", executor.getPoolSize());
        System.out.printf("Server: Active Count: %d\n", executor.getActiveCount());
        System.out.printf("Server: Task Count: %d\n", executor.getTaskCount());
        System.out.printf("Server: Completed Tasks: %d\n", executor.getCompletedTaskCount());
    }
//15．实现endServer()方法。在这个方法中，调用执行器的shutdown()方法来终止执行器：
    public void endServer(){
        executor.shutdown();
    }
}
```

四. TestMain测试类

```java
//16．至此，我们可以开始实现应用程序的入口，创建包含main()方法的Main类。首先，创建100个任务并将其提交给Executor：
public class TestMain {

    public static void main(String[] args) {
        Server server = new Server();
        System.out.println("Main: Starting... ");
        for (int i = 0; i < 100 ; i++) {
            Task task = new Task("Task" + i);
            server.executeTask(task);
        }
//17．调用Server类中的endServer()方法来终止执行器：
        System.out.println("Main: Shutting down the Executor.");
        server.endServer();
//18．提交一个新的任务。由于这个任务会被拒绝，因此我们可以看到拒绝策略是如何生效的：
        System.out.println("Main: Sending another Task.");
        Task rejected_task = new Task("Rejected task");
        server.executeTask(rejected_task);
        System.out.println("Main: End!");
    }
}
```



其他APi

ThreadPoolExecutor类也提供了其他与终止线程执行器相关的方法，具体如下。

* shutdownNow()：该方法会立刻终止执行器，而非执行现存的任务。虽然该方法会返回一个现存任务的列表，已经执行的任务会在调用方法后继续执行，但是该方法会直接返回结果，而非等待它们运行完成。
*  isTerminated()：该方法用来判断是否执行器处于结束过程。如果调用了shutdown()或shutdownNow()方法，则该方法会返回true。
*  isShutdown()：如果调用了执行器的shutdown()方法，则该方法会返回true。
*  awaitTermination(long timeout, TimeUnit unit)：该方法会阻塞调用线程直到执行器关闭或是超时。TimeUnit类是一系列常量的枚举：DAYS、HOURS、MICROSECONDS、MILLISECONDS、MINUTES、NANOSECONDS和SECONDS。

## 运行多个任务并处理第一个返回结果

一.创建`UserValidator`类

```java
/**
 * 1．创建一个名为UserValidator的类，并实现用户校验的逻辑：
 * @author wang
 */
public class UserValidator {
//2．声明一个名为name的私有String变量——用来存储用户校验系统的名称：
    private final String name;
//3．实现该类的构造方法并初始化类中变量：
    public UserValidator(String name){
        this.name = name;
    }
//4．实现validate()方法。该方法接收两个String类型的参数，它们分别为需要校验的名称和密码：
    public boolean validate(String name, String password){
//5．创建一个名为random的Random对象：
        Random random = new Random();
//6．随机等待一段时间后，模拟用户校验过程
        try {
            long duration = ThreadLocalRandom.current().nextLong(5);
            System.out.printf("Validator %s: Validating a user during %d seconds\n", this.name, duration);
            TimeUnit.SECONDS.sleep(duration);
        } catch (InterruptedException e) {
            return false;
        }
//7．返回一个随机的布尔值。如果用户校验通过，则validate()方法返回true，否则返回false：
        return random.nextBoolean();
    }
//8．实现getName()方法。该方法返回变量name的值：
    public String getName(){
        return this.name;
    }
}
```

二. 创建`ValidatorTask`类

```java
/**
 * 9．创建一个名为ValidatorTask的类，并发使用UserValidation类来执行校验过程，并实现泛型为String的Callable接口：
 * @author wang
 */
public class ValidatorTask implements Callable<String> {
//10．声明一个类型为UserValidator名为validator的私有变量：
    private final UserValidator validator;
//11．声明两个私有String型变量，它们分别名为name和password：
    private final String name;
    private final String password;
//12．实现类的构造方法并初始化全部变量：
    public ValidatorTask(UserValidator validator, String name, String password){
        this.validator = validator;
        this.name = name;
        this.password = password;
    }
//13．实现call()方法并返回一个String型对象：
    @Override
    public String call() throws Exception {
//14．如果name未通过UserValidator对象的校验，则在控制台打印信息记录并抛出Exception：
        if (!validator.validate(name, password)){
            System.out.printf("%s : The user has not been found\n", validator.getName());
            throw new Exception("Error validating user");
        }
//15．在控制台打印信息通过校验的用户信息，并返回UserValidator实例对象的name值：
        System.out.printf("%s: The user has been found\n", validator.getName());
        return validator.getName();
    }
}
```

三.创建测试类`TestMain`

```java
/**
 * 创建包含main()方法的TestMain类：
 *
 * @author wang
 */
public class TestMain {
    public static void main(String[] args) {
//17．创建两个String型对象，分别命名为name和password，并使用测试值初始化它们
        String name = "test";
        String password = "test";
//18．创建两个UserValidator对象，分别命名为ldapValidator和dbValidator：
        UserValidator ldapValidator = new UserValidator("LDAP");
        UserValidator dbValidator = new UserValidator("DataBase");
//19．创建两个TaskValidator对象，分别命名为ldapTask和dbTask。分别用ldapValidator和dbValidator初始化它们：
        ValidatorTask ldapTask = new ValidatorTask(ldapValidator, name, password);
        ValidatorTask dbTask = new ValidatorTask(dbValidator, name, password);
//20．创建一个TaskValidator对象的列表，并把创建的两个对象添加进去：
        List<ValidatorTask> taskList = new ArrayList<>();
        taskList.add(ldapTask);
        taskList.add(dbTask);
//21．使用Executors的newCachedThreadPool创建一个新的ThreadPoolExecutor对象，并创建一个名为result的字符型变量
        ExecutorService executorService = Executors.newCachedThreadPool();
//22．调用执行器的invokeAny()方法。该方法接收taskList作为参数，并返回String型结果，并且将该方法的返回值打印到控制台：
        String result;
        try {
            result  = executorService.invokeAny(taskList);
            System.out.printf("Main : Result: %s\n", result);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
//23．调用shutdown()方法终止执行器，并在控制台打印信息来表明程序已经终止：
        executorService.shutdown();
        System.out.println("Main: End of the Execution\n");
    }
}
```

本案例包含两个随机返回的布尔型的`UserValidato`r对象。每个`UserValidator`对象都由一个实现了Callable接口的`ValidatorTask`对象所调用。如果`UserValidator`类中的`validate()`方法返回false，则`ValidatorTask`类会抛出一个异常；否则返回true。若是提交了两个返回true或是抛出异常的任务，则它们会有如下4种可能。

* 两个任务都返回true。然后`invokeAny()`方法会返回第一个执行完成任务的名称。
*  第一个任务返回true，而第二个任务抛出异常。然后，`invokeAny()`方法会返回第一个任务的名称。
* 第一个任务抛出异常，而第二个任务返回true。然后，`invokeAny()`方法会返回第二个任务的名称。
* 两个任务都抛出异常。在这种情况下，`invokeAny()`方法抛出一个`Execution-Exception`异常。

`ThreadPoolExecutor`提供了另一个版本的`invokeAny()`方法。

* `invokeAny(Collection<? extends Callable> tasks, longtimeout, TimeUnit unit)`：该方法执行全部任务并返回第一个正常运行结束且未抛出异常和未超过设定时间的任务执行结果。TimeUnit类对象是一个枚举类，它包括DAYS、HOURS、MICROSECONDS、MILLISECONDS、MINUTES、NANOSECONDS、和SECONDS。

## 运行多任务并返回所有任务的结果

`ThreadPoolExecutor`提供`List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)`方法返回全部任务的执行结果,返回集合的结果的顺序对应参数集合的顺序

## 在执行器中延迟运行任务

```java
ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(1);
// ScheduledExecutorService schedule 方法执行延迟执行的方法,可以传Callable 或 Runnable对象
ScheduledFuture<V> schedule(Callable<V> callable,
                                           long delay, TimeUnit unit)
// 周期性的执行任务,可以传Callable 或 Runnable对象
ScheduledFuture<?> scheduleAtFixedRate(Runnable command,
                                                  long initialDelay,
                                                  long period,
                                                  TimeUnit unit)
```

## 执行器取消任务

若想取消一个已经提交给执行器的任务，则可以使用Future接口的cancel()方法。该方法的作用随着传入参数和任务状态的不同而变化。

* 如果任务已经结束，或在更早之前已取消，或是其他原因不能取消，则该方法将会返回false且不会取消任务。
*  如果任务在等着执行器分配线程，则这个任务会取消，不会再次调度。如果该任务已经在执行，则要视传入参数而定。cancel()方法接收一个布尔值作为参数。如果参数值为true，则会取消正在执行的任务；否则正在执行的任务不会取消

```java
Future<String> result = executor.submit(task);
//取消任务
result.cancel();
```

## 在执行器内控制任务的完成

一. 创建执行任务的Task类

```java
/**
 * Created on 2020/7/19
 * 1．创建一个实现Callable接口且泛型为String的名为ExecutableTask的类：
 * @author wang
 */
public class ExecutableTask implements Callable<String> {

//2. 声明一个名为name的私有String型变量，用来存储任务名称。
    private final String name;
    public String getName(){
        return this.name;
    }
//3．实现该类的构造方法，并初始化任务名称：
    public ExecutableTask(String name){
        this.name = name;
    }
//4．实现call()方法，让任务休眠一段随机时间并返回任务名称等信息：
    @Override
    public String call() throws Exception {
        long duration = ThreadLocalRandom.current().nextLong(5);
        System.out.printf("%s : Waiting %d seconds for results.\n", this.name, duration);
        TimeUnit.SECONDS.sleep(duration);
        return "Hello, world, I'm "+name;
    }
}
```



二. 创建一个接受结果的任务类

```java
/**
 * Created on 2020/7/19
 * 5．实现一个名为ResultTask的类。该类继承FutureTask类，泛型类型为String：
 * @author wang
 */
public class ResultTask extends FutureTask<String> {

 //6．声明一个名为name的私有String型变量，它用来存储任务名称：
    private final String name;

//7．实现该类的构造方法，该方法接收一个Callable实例对象作为参数。调用该类父类构造方法并使用接收的任务属性来初始化name变量：
    public ResultTask(ExecutableTask callable) {
        super(callable);
        this.name = callable.getName();
    }
//8．重写done()方法。检查isCancelled()方法的值并根据返回值在控制台打印返回信息：
    @Override
    protected void done() {
        if (isCancelled()){
            System.out.printf("%s: Has been canceled\n", name);
        }else {
            System.out.printf("%s: Has finished\n", name);
        }
    }
}
```



三. 创建测试类

```java
/**
 * Created on 2020/7/19
 * 9. 创建包含main()方法的测试类：
 * @author wang
 */
public class TestMain {
    public static void main(String[] args) {
 //10．使用Executors类中的newCachedThreadPool创建ExecutorService实例对象：
        ExecutorService executor = Executors.newCachedThreadPool();
 //11．创建一个数组用来存储5个ResultTask对象：
        ResultTask[] resultTask = new ResultTask [5];
//12．初始化ResultTask对象。对数组中的每个元素，首先创建ExecutableTask对象，并使用该对象创建ResultTask对象；随后使用submit()方法提交ResultTask对象到执行器：
        for (int i = 0; i < 5 ; i++) {
            ExecutableTask executableTask = new ExecutableTask("Task" + i);
            resultTask[i] = new ResultTask(executableTask);
            executor.submit(resultTask[i]);
        }
 //13．让主线程休眠1s：
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
//14．取消提交给执行器的全部任务：
        for (int i = 0; i < resultTask.length ; i++) {
            resultTask[i].cancel(true);
        }
//15．用ResultTask对象的get()方法获取还未取消的对象信息，并在控制台打印出来：
        for (int i = 0; i < resultTask.length ; i++) {
                try {
                    if (!resultTask[i].isCancelled()) {
                        System.out.printf("%s\n", resultTask[i].get());
                    }
                } catch (InterruptedException | ExecutionException e) {
                    e.printStackTrace();
                }
        }
//16．调用shutdown()方法关闭执行器：
        executor.shutdown();
    }
}
```

四. 运行结果分析

```java
Task1 : Waiting 3 seconds for results.
Task2 : Waiting 0 seconds for results.
Task3 : Waiting 0 seconds for results.
Task4 : Waiting 3 seconds for results.
Task0 : Waiting 3 seconds for results.
Task3: Has finished
Task2: Has finished
Task0: Has been canceled
Task1: Has been canceled
Task4: Has been canceled
Hello, world, I'm Task2
Hello, world, I'm Task3
```

可以看到task2,task3在任务取消之前执行完成了,其他的任务被取消了

当任务结束运行时，管理任务的FutureTask对象会调用done()方法。在本案例中，用实现了Callable接口的ExecutableTask类和一个FutureTask的子类来管理ExecutableTask实例对象的执行。当FutureTask类确定了任务的返回值，并将任务状态改为isDone后，它会间歇性地调用done()方法。虽然这时不能修改任务的返回值或是状态，但是可以关闭任务使用的资源，打印日志信息或是发送通知。FutureTask类也可以通过只调用一次其重写的Runnable或Callable接口的run()方法来确保一个指定的任务只运行一次（当运行结果可见时可以获取结果）。

### 当提交任务给执行器时，使用一个对象来提交，并想在另一个对象中处理返回结果

见`CompletionService.md`





<<Java 9 并发编程实战>>

