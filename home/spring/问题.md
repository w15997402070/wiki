---
title: 问题
description: 
published: true
date: 2020-09-16T13:55:20.232Z
tags: 
editor: markdown
---

# 问题?

[toc]

## springboot aop 无法嵌套方法中使用注解

例: 

```java
@Target({ElementType.METHOD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface ErrorLog {

    String value() default "";

    String type() default "";

}

@Aspect
@Component
public class ErrorLogAspect {

    @Pointcut("@annotation( com.wang.search.componet.ErrorLog )")
    public void logAspect() {
    }
   
    @Before("logAspect()")
    public void addBeforeLogger(JoinPoint joinPoint) {
        System.out.println("before");
    }
}
```



```java
@Service
public class SearchServiceImpl implements SearchService {
    
    @ErrorLog
    @Override
    public int save(SearchModal searchModal) {
        beforeSave()
        save(searchModal)
        return searchModalList.size();
    }
    
    @ErrorLog
    public void beforeSave(){
        System.out.println("before save");
    }
}
```

以上代码调用`save`方法会触发` @ErrorLog`注解,也就是会打印出"before",但是`beforeSave`方法虽然也加了注解但是不会触发注解,也就不会打印出什么了.

解决这个问题可以注入自己再调用before方法,这样就会都可以打印出"before'了

```java
@Service
public class SearchServiceImpl implements SearchService {
     @Autowired
    private SearchService SearchService;
    @ErrorLog
    @Override
    public int save(SearchModal searchModal) {
        //注意这里使用注入的bean调用的
        SearchService.beforeSave()
        save(searchModal)
        return searchModalList.size();
    }
    
    @ErrorLog
    public void beforeSave(){
        System.out.println("before save");
    }
}
```



## Bean

循环依赖处理?原型模式依赖处理?

[循环依赖处理](/home/spring/Spring循环依赖)



### BeanFactory与FactoryBean?

BeanFactory 是 生成Bean的工厂

FactoryBean 是对bean

### 转义符“&"的用处?

如果获取 `FactoryBean `就可以在`getBean("test")`时加`&`,即``getBean("&test")``

不加`&`获取的是Bean 加 `&` 获取的是 FactoryBean

### XmlBeanFactory 

 ApplicationContext IoC容器的高级表现形式它与BeanFactory相比的增强特性

### 后置处理器 BeanPostProcessor?

[Spring BeanPostProcessor](D:\data\notes\notes\spring\Spring BeanPostProcessor.pdf)

## MVC

`HandlerMethodArgumentResolverComposite`解析请求参数的入口处?

```
//http请求到
FrameworkServlet # service()
FrameworkServlet # processRequest()
DispatcherServlet # doService()
DispatcherServlet # doDispatch()
        //ha = HandlerAdapter -> RequestMappingHandlerAdapter
		mv = ha.handle(processedRequest, response, mappedHandler.getHandler());
AbstractHandlerMethodAdapter # handle()
AbstractHandlerMethodAdapter # handleInternal()
RequestMappingHandlerAdapter # handleInternal()
RequestMappingHandlerAdapter # invokeHandlerMethod() -->
ServletInvocableHandlerMethod # invokeAndHandle()  -->
    InvocableHandlerMethod    # invokeForRequest()
    InvocableHandlerMethod    # getMethodArgumentValues()
                                  args[i] = this.resolvers.resolveArgument(parameter, mavContainer, request, this.dataBinderFactory);
HandlerMethodArgumentResolverComposite # resolveArgument()			
```

InvocableHandlerMethod 代码:

```java
public class InvocableHandlerMethod extends HandlerMethod {
    //初始化参数解析器
    private HandlerMethodArgumentResolverComposite resolvers = new HandlerMethodArgumentResolverComposite();
    
    
    protected Object[] getMethodArgumentValues(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer,
			Object... providedArgs) throws Exception {

		MethodParameter[] parameters = getMethodParameters();
		if (ObjectUtils.isEmpty(parameters)) {
			return EMPTY_ARGS;
		}

		Object[] args = new Object[parameters.length];
		for (int i = 0; i < parameters.length; i++) {
			MethodParameter parameter = parameters[i];
			//设置参数名解析器
			parameter.initParameterNameDiscovery(this.parameterNameDiscoverer);
			args[i] = findProvidedArgument(parameter, providedArgs);
			if (args[i] != null) {
				continue;
			}

			if (!this.resolvers.supportsParameter(parameter)) {
				throw new IllegalStateException(formatArgumentError(parameter, "No suitable resolver"));
			}
			try {
				//使用 ArgumentResolvers解析参数
				args[i] = this.resolvers.resolveArgument(parameter, mavContainer, request, this.dataBinderFactory);
			}
			catch (Exception ex) {
				// Leave stack trace for later, exception may actually be resolved and handled...
				if (logger.isDebugEnabled()) {
					String exMsg = ex.getMessage();
					if (exMsg != null && !exMsg.contains(parameter.getExecutable().toGenericString())) {
						logger.debug(formatArgumentError(parameter, exMsg));
					}
				}
				throw ex;
			}
		}
		return args;
	}
}
```

HandlerMethodArgumentResolverComposite # resolveArgument()

```java
    @Override
	@Nullable
	public Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,
			NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception {

		HandlerMethodArgumentResolver resolver = getArgumentResolver(parameter);
		if (resolver == null) {
			throw new IllegalArgumentException("Unsupported parameter type [" +
					parameter.getParameterType().getName() + "]. supportsParameter should be called first.");
		}
		return resolver.resolveArgument(parameter, mavContainer, webRequest, binderFactory);
	}
```

```java
    @Nullable
	private HandlerMethodArgumentResolver getArgumentResolver(MethodParameter parameter) {
		HandlerMethodArgumentResolver result = this.argumentResolverCache.get(parameter);
		if (result == null) {
			for (HandlerMethodArgumentResolver resolver : this.argumentResolvers) {
				if (resolver.supportsParameter(parameter)) {
					result = resolver;
					this.argumentResolverCache.put(parameter, result);
					break;
				}
			}
		}
		return result;
	}
```



解析流程

Controller怎么转换成HandlerMapping

### WebAsyncUtils.getAsyncManager什么用?

异步请求