# Spring循环依赖

循环依赖就是循环引用，就是两个或多个bean相互之间的持有对方，比如CircleA引用CircleB，CircleB引用CircleC，CircleC引用CircleA，则它们最终反映为一个环

![image-20200216132225152](D:\data\notes\notes\spring\循环依赖\image-20200216132225152.png)

```java
public class TestA {

    private TestB testB;

    public void a(){
       testB.b();
    }

    public TestB getTestB() {
        return testB;
    }

    public void setTestB(TestB testB) {
        this.testB = testB;
    }
}
```

```java
public class TestB {

    private TestC testC;

    public void b(){
        testC.c();
    }

    public TestC getTestC() {
        return testC;
    }

    public void setTestC(TestC testC) {
        this.testC = testC;
    }
}
```

```java
public class TestC {

    private TestA testA;

    public void c(){
        testA.a();
    }

    public TestA getTestA() {
        return testA;
    }

    public void setTestA(TestA testA) {
        this.testA = testA;
    }
}
```

## 1.构造器循环依赖

表示通过构造器注入构成的循环依赖，此依赖是无法解决的，只能抛出BeanCurrentlyInCreationException异常表示循环依赖。

如在创建TestA类时，构造器需要TestB类，那将去创建TestB，在创建TestB类时又发现需要TestC类，则又去创建TestC，最终在创建TestC时发现又需要TestA，从而形成一个环，没办法创建。

Spring容器将每一个正在创建的bean标识符放在一个“当前创建bean池”中，bean标识符在创建过程中将一直保持在这个池中，因此如果在创建bean过程中发现自己已经在“当前创建bean池”里时，将抛出BeanCurrentlyInCreationException异常表示循环依赖；而对于创建完毕的bean将从“当前创建bean池”中清除掉。

在TestA,TestB,TestC,添加带参数的构造函数

在xml中添加配置

```xml
	<bean id="testA" class="com.spring.demo.bean.cycle.TestA">
       <constructor-arg index="0" ref="testB"/>
   </bean>
    <bean id="testB" class="com.spring.demo.bean.cycle.TestB">
        <constructor-arg index="0" ref="testC"/>
    </bean>
    <bean id="testC" class="com.spring.demo.bean.cycle.TestC">
        <constructor-arg index="0" ref="testA"/>
    </bean>
```

```java
public class CycleTest {

    public static void main(String[] args) {
        ClassPathXmlApplicationContext applicationContext =
                new ClassPathXmlApplicationContext("application-content.xml");
        TestA  testA = (TestA)applicationContext.getBean("testA");
        System.out.println(testA.toString());
    }
}
```

执行测试类会报错

## 2.setter循环依赖

表示通过setter注入方式构成的循环依赖。对于setter注入造成的依赖是通过Spring容器提前暴露刚完成构造器注入但未完成其他步骤（如setter注入）的bean来完成的，而且只能解决单例作用域的bean循环依赖。通过提前暴露一个单例工厂方法，从而使其他bean能引用到该bean，

## 3.prototype范围的依赖处理

对于“prototype”作用域bean，Spring容器无法完成依赖注入，因为Spring容器不进行缓存“prototype”作用域的bean，因此无法提前暴露一个创建中的bean

xml配置文件添加scope参数

```xml
 <bean id="testA" class="com.spring.demo.bean.cycle.TestA" scope="prototype">
       <property name="testB" ref="testB"/>
   </bean>
    <bean id="testB" class="com.spring.demo.bean.cycle.TestB" scope="prototype">
        <property name="testC" ref="testC"/>
    </bean>
    <bean id="testC" class="com.spring.demo.bean.cycle.TestC" scope="prototype">
        <property name="testA" ref="testA"/>
    </bean>
```

执行测试类会报错