### RocketMQ

[toc]

<<RocketMQ分布式消息中间件：核心原理与最佳实践>>



## RocketMQ相关概念

### Namesrv

Namesrv 之于 RocketMQ，即 Zookeeper 之于 Kafka，即服务注册中心之于微服务。Namesrv在RocketMQ体系中是一个Topic路由注册和管理、Broker注册和发现的管理者。

### Broker

Broker是RocketMQ体系中的核心组件之一，存储是Broker的核心功能之一，决定整个RocketMQ体系的吞吐性能、可靠性和可用性



### 生产者

RocketMQ支持3种消息：普通消息（并发消息）、顺序消息、事务消息

RocketMQ支持3种发送方式：同步发送、异步发送、单向发送

#### 生产者相关概念

生产者组：一个逻辑概念，在使用生产者实例的时候需要指定一个组名。一个生产者组可以生产多个Topic的消息。

生产者实例：一个生产者组部署了多个进程，每个进程都可以称为一个生产者实例。

Topic：主题名字，一个Topic由若干Queue组成。

RocketMQ 客户端中的生产者有两个独立实现类：`org.apache.rocketmq.client.producer.DefaultMQProducer`和`org.apache.rocketmq.client.producer.TransactionMQProducer`。前者用于生产普通消息、顺序消息、单向消息、批量消息、延迟消息，后者主要用于生产事务消息。

RocketMQ支持普通消息、分区有序消息、全局有序消息、延迟消息和事务消息。

普通消息：普通消息也称为并发消息，和传统的队列相比，并发消息没有顺序，但是生产消费都是并行进行的，单机性能可达十万级别的TPS。

分区有序消息：与Kafka中的分区类似，把一个Topic消息分为多个分区“保存”和消费，在一个分区内的消息就是传统的队列，遵循FIFO（先进先出）原则。

全局有序消息：如果把一个 Topic 的分区数设置为 1，那么该 Topic 中的消息就是单分区，所有消息都遵循FIFO（先进先出）的原则。

延迟消息：消息发送后，消费者要在一定时间后，或者指定某个时间点才可以消费。在没有延迟消息时，基本的做法是基于定时计划任务调度，定时发送消息。在RocketMQ中只需要在发送消息时设置延迟级别即可实现。

事务消息：主要涉及分布式事务，即需要保证在多个操作同时成功或者同时失败时，消费者才能消费消息。RocketMQ通过发送Half消息、处理本地事务、提交（Commit）消息或者回滚（Rollback）消息优雅地实现分布式事务。

#### 生产者高可用

通常，我们希望不管Broker、Namesrv出现什么情况，发送消息都不要出现未知状态或者消息丢失。在消息发送的过程中，客户端、Broker、Namesrv 都有可能发生服务器损坏、掉电等各种故障。当这些故障发生时，RocketMQ是怎么处理的呢？

1.客户端保证

第一种保证机制：重试机制。RocketMQ 支持同步、异步发送，不管哪种方式都可以在配置失败后重试，如果单个 Broker 发生故障，重试会选择其他 Broker 保证消息正常发送。

第二种保证机制：客户端容错。RocketMQ Client会维护一个“Broker-发送延迟”关系，根据这个关系选择一个发送延迟级别较低的 Broker 来发送消息，这样能最大限度地利用 Broker 的能力，剔除已经宕机、不可用或者发送延迟级别较高的 Broker，尽量保证消息的正常发送。

2.Broker端保证

数据同步方式保证,Broker主从复制分为两种：同步复制和异步复制。同步复制是指消息发送到Master Broker后，同步到SlaveBroker才算发送成功；异步复制是指消息发送到Master Broker，即为发送成功。在生产环境中，建议至少部署2个Master和2个Slave

### 消费者

消费者一般指获取消息、转发消息给业务代码处理的一系列代码实现

RocketMQ消费者支持订阅发布模式和Queue模式

#### 消费者相关概念

消费者组：一个逻辑概念，在使用消费者时需要指定一个组名。一个消费者组可以订阅多个Topic。

消费者实例：一个消费者组程序部署了多个进程，每个进程都可以称为一个消费者实例。

订阅关系：一个消费者组订阅一个 Topic 的某一个 Tag，这种记录被称为订阅关系。RocketMQ规定消费订阅关系（消费者组名-Topic-Tag）必须一致——在此，笔者想提醒读者，一定要重视这个问题，一个消费者组中的实例订阅的Topic和Tag必须完全一致，否则就是订阅关系不一致。订阅关系不一致会导致消费消息紊乱。

#### 消费模式

RocketMQ目前支持集群消费模式和广播消费模式，其中集群消费模式使用最为广泛。

1.集群消费模式

在同一个消费者组中的消费者实例，是负载均衡（策略可以配置）地消费Topic中的消息，假如有一个生产者（Producer）发送了 120 条消息，其所属的 Topic 有3 个消费者（Consumer）组，每个消费者组设置为集群消费，分别有2个消费者实例，

2.广播消费模式

广播消费，顾名思义全部的消息都是广播分发，即消费者组中的全部消费者实例将消费整个 Topic 的全部消息。比如，有一个生产者生产了 120 条消息，其所属的Topic 有 3个消费者组，每个消费者组设置为广播消费，分别有两个消费者实例，

#### 可靠消费

RocketMQ是一种十分可靠的消息队列中间件，消费侧通过重试-死信机制、Rebalance机制等多种机制保证消费的可靠性

##### 1.重试-死信机制

RocketMQ的消费过程分为 3个阶段：正常消费、重试消费和死信

正常Topic：正常消费者订阅的Topic名字。

重试 Topic：如果由于各种意外导致消息消费失败，那么该消息会自动被保存到重试Topic中，格式为“%RETRY%消费者组”，在订阅的时候会自动订阅这个重试Topic。

进入重试队列的消息有16次重试机会，每次都会按照一定的时间间隔进行，如表3-1所示。RocketMQ 认为消费不是一锤子买卖，可能由于各种偶然因素导致正常消费失败，只要正常消费或者重试消费中有一次消费成功，就算消费成功。

![image-20210307205347597](https://raw.githubusercontent.com/w15997402070/images/main/note/image-20210307205347597.png)

死信Topic：死信Topic名字格式为“%DLQ%消费者组名”。如果正常消费1次失败，重试16次失败，那么消息会被保存到死信Topic中，进入死信Topic的消息不能被再次消费。RocketMQ认为，如果17次机会都失败了，说明生产者发送消息的格式发生了变化，或者消费服务出现了问题，需要人工介入处理。

彩蛋：如果有一天你的数据消费失败，发现是因为消费代码有bug，修复后再上线，想补偿之前消费失败的死信数据，怎么办呢？

##### 2.Rebalance机制

Rebalance（重平衡）机制，用于在发生Broker掉线、Topic扩容和缩容、消费者扩容和缩容等变化时，自动感知并调整自身消费，以尽量减少甚至避免消息没有被消费。后面会详细讲述Rebalance的过程



### 消息过滤

RocketMQ 4.2.0支持Tag过滤、SQL92过滤、Filter Server过滤

## 问题？

### 为什么需要消息队列？

#### 削峰填谷

扩容服务器可以解决访问量大的问题。但是平时访问量少的时候就会造成很大的资源浪费。

#### 程序间解耦

不同的业务端在联合开发功能时，常常由于排期不同、人员调配不方便等原因导致项目延期。其实，其根本原因是业务耦合过度。

上下游系统之间的通信是彼此依赖的，所以不得不协调上下游所有的资源同步进行，跨团队处理问题显然比在团队内部处理问题难度大

![image-20210307202849012](https://raw.githubusercontent.com/w15997402070/images/main/note/image-20210307202849012.png)

你是否依稀记得另一个团队的同事调用你的API，你告诉他发个请求过来，你打断点一步一步调试代码的场景？你是否记得为了协调开发资源、QA 资源，以及协调上线时间等所做的一切，你被老板骂了多少次，最后还是延期了：我们依赖他们，他们的QA说，高峰期不让发布。

加入消息队列后，不同的业务端又会是何种情况呢？如图1-5所示，上下游系统进行开发、联调、上线，彼此完全不依赖，也就是说，系统间解耦了。

![image-20210307203027847](https://raw.githubusercontent.com/w15997402070/images/main/note/image-20210307203027847.png)

#### 异步处理

耗时的操作，我们可以通过使用消息队列的方式，把提交请求成功的消息告诉用户。然后异步处理这些耗时的操作

#### 数据的最终一致性

例如一般的转账业务

![image-20210307203448331](https://raw.githubusercontent.com/w15997402070/images/main/note/image-20210307203448331.png)

如果通信失败，怎么保证你的钱转账成功了呢？

业内常用的手段就是消息队列。消息系统的优点：

（1）免去了招商银行App多次重试（发起请求）的复杂逻辑。

（2）免去了北京银行App处理过多重试请求的压力。

（3）即使北京银行服务不可用，业务也不受影响。