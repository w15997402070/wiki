# RabbitMQ协议和交互原理

[toc]

`<<深入RabbitMQ>>` 作者: 加文·罗伊

关键词: `帧结构`  `5个帧组件`  `5种帧类型`  `交换器`  `队列`  `路由` `生产者` `消费者`

## AMQ协议

RabbitMQ在与核心产品进行通信的各个方面几乎都采用了远程过程调用（Remote Procedure Call，RPC）模式



## RabbitMQ连接过程

### 启动会话

当与AMQP交互时,客户端发送给服务器协议头（protocol header）进行确认,RabbitMQ通过Connection.Start命令响应问候语来启动命令/响应序列，而客户端则使用Connection.StartOk响应帧来响应RPC请求

![image-20200721222752549](D:\data\notes\notes\消息队列\RabbitMQ\RabbitMQ协议和交互原理\image-20200721222752549.png)

### 与RabbitMQ进行通信的信道

在AMQP中，信道使用协商的AMQP连接作为相互传输信息的渠道，而且它们将传输过程与其他正在进行中的会话隔离开来，这点也和双向无线电信道类似。一个AMQP连接可以有多个信道，允许客户端和服务器之间进行多次会话。从技术上讲，这被称为多路复用（multiplexing），对于执行多个任务的多线程或异步应用程序来说，它非常有用。

在创建客户端应用程序时，不要使用过多的信道使事情变得复杂。在编组帧的线路上，信道不过是分配给服务器和客户端之间所传递消息的一个整数值；而在RabbitMQ服务器和客户端中，它们代表更多的含义。因为会为每个信道设置内存结构和对象，连接中的信道越多，RabbitMQ用于管理该连接的消息流所需的内存也就越多。如果你能合理地使用它们，你将会有一个更健康的RabbitMQ服务器和一个更简洁的客户端应用程序。

## AMQP RPC帧

### AMQP RPC帧结构

AMQP使用类和方法在客户端和服务器之间创建公共语言，这些类和方法被称为AMQP命令（AMQP commands）

AMQP中的类定义了一个功能范围，每个类都包含执行不同任务的方法。在连接协商过程中，RabbitMQ服务器发送一个Connection.Start命令，然后编组成一个帧并发送给客户端。如图2.2所示，Connection.Start命令由两个组件组成：AMQP类（Class）和方法（Method）。

![image-20200721223042126](D:\data\notes\notes\消息队列\RabbitMQ\RabbitMQ协议和交互原理\image-20200721223042126.png)

### AMQP帧组件

当使用命令与RabbitMQ进行交互时，执行这些命令所需的所有参数被封装在一个称为帧的数据结构中，帧对数据进行编码以便传输。

低层AMQP帧由五个不同的组件组成：

* 帧类型
* 信道编号
* 以字节为单位的帧大小
* 帧有效载荷
* 结束字节标记（ASCII值206）

![image-20200721223242579](D:\data\notes\notes\消息队列\RabbitMQ\RabbitMQ协议和交互原理\image-20200721223242579.png)

低层AMQP帧的头部是三个字段，这三个字段组合起来被称为帧头（frame header）。第一个字段是指示帧类型的单个字节，第二个字段指定帧的信道，第三个字段携带帧有效载荷的字节大小。帧头和结束字节标记合在一起创建了帧的基本结构。在帧内部，位于头部之后和结束字节标记之前的内容就是帧的有效载荷。就像货车上的货箱能够保护自身内部物品一样，帧的设计也是为了保护其携带内容的完整性。

### 帧类型

AMQP规范定义了五种类型的帧：协议头帧、方法帧、内容头帧、消息体帧及心跳帧。	

* 协议头帧用于连接到RabbitMQ，仅使用一次。
* 方法帧携带发送给RabbitMQ或从RabbitMQ接收到的RPC请求或响应。
* 内容头帧包含一条消息的大小和属性。
* 消息体帧包含消息的内容。
* 心跳帧在客户端与RabbitMQ之间进行传递，作为一种校验机制确保连接的两端都可用且在正常工作。

注意 AMQP中的心跳行为用于确保客户端和服务器之间相互响应，这是展示AMQP作为一种双向RPC协议的完美示例。如果RabbitMQ发送心跳到你的客户端应用程序，然后没有得到响应，RabbitMQ就会断开连接。通常情况下，单线程或异步开发环境下的开发人员会希望将超时时间设置为一个较大的值。如果你发现你的应用程序在一定程度上阻塞了通信，使得心跳机制难以正常运作，那么可以在创建客户端连接时将心跳间隔设置为0来关闭它们。相反，如果你选择使用比默认值600秒高得多的值，则可以通过更改rabbitmq.config文件中的heartbat值来更改RabbitMQ的最大心跳间隔。

### 将消息编组成帧

我们使用方法帧、内容头帧和消息体帧向RabbitMQ发布消息。发送的第一个帧是携带命令和执行它所需参数（如交换器和路由键）的方法帧。方法帧之后是内容帧，包含内容头和消息体。内容头帧包含消息属性以及消息体大小。AMQP的帧大小有一个上限，如果消息体超过这个上限，消息内容将被拆分成多个消息体帧。这些帧始终以相同的顺序发送：方法帧、内容头帧以及一个或多个消息体帧

![image-20200721223614940](D:\data\notes\notes\消息队列\RabbitMQ\RabbitMQ协议和交互原理\image-20200721223614940.png)

为了更高效地处理并最小化传输的数据大小，方法帧和内容头帧中的内容是人眼不可读的二进制打包数据。而与方法帧和内容头帧不同，在消息体帧内部携带的消息内容没有进行任何打包或编码，可以包含从纯文本到二进制图像数据的任何内容。

### 方法帧结构

方法帧携带着构建RPC请求所需的类、方法以及相关参数。在图2.5中，携带Basic.Publish命令的方法帧中包含着描述该命令的二进制打包数据以及与其一起传递的请求参数。前两个字段是Basic类和Publish方法的数字表示。这些字段后面跟着交换器和路由键的字符串值。正如前文所述，这些属性告知RabbitMQ如何路由消息。Mandatory标志则告知RabbitMQ消息必须投递成功，否则发布消息的过程就应该是失败的。

![image-20200721223958962](D:\data\notes\notes\消息队列\RabbitMQ\RabbitMQ协议和交互原理\image-20200721223958962.png)

### 内容头帧

在方法帧之后发送的消息头除了告知RabbitMQ该消息的大小之外，还有很多其他数据。如图2.6所示，消息头帧还包含消息的各种属性，为RabbitMQ服务器和可能接收它的任何应用程序提供了对消息的描述。这些属性存储在Basic.Properties映射表中，可能包含描述消息内容的数据，也可能是完全空白。大多数客户端库将预先填充一小部分字段，比如内容类型和投递模式。

![image-20200721224058835](D:\data\notes\notes\消息队列\RabbitMQ\RabbitMQ协议和交互原理\image-20200721224058835.png)

### 消息体帧

消息的消息体帧与正在传输的数据类型无关，并且可能包含二进制或文本数据。无论你是发送如JPEG图片的二进制数据，或是序列化之后的JSON、XML格式数据，消息体帧都是消息中包含实际消息数据的结构（见图2.7）。

![image-20200721224155210](D:\data\notes\notes\消息队列\RabbitMQ\RabbitMQ协议和交互原理\image-20200721224155210.png)

消息属性和消息体组合在一起构成了数据的强大封装格式。将消息的描述性属性与内容无关的消息体结合起来，确保你可以使用RabbitMQ来处理你认为合适的任何类型的数据。	

## 消息发送步骤

### 声明交换器

使用Exchange.Declare命令可以创建交换器，该命令提供了定义交换器名称和类型的参数，以及用于消息处理的其他元数据。

一旦命令被发送，RabbitMQ在创建了交换器之后将发送一个Exchange.DeclareOk方法帧作为响应（见图2.8）。如果出于某种原因命令执行失败，则RabbitMQ将使用Channel.Close命令关闭发送Channel.Declare命令的信道。该响应将包含一个数字回复编码和文本值，用于说明Exchange.Declare失败并关闭信道的原因。

![image-20200721224414983](D:\data\notes\notes\消息队列\RabbitMQ\RabbitMQ协议和交互原理\image-20200721224414983.png)

### 声明队列

一旦交换器创建成功，就可以通过发送Queue.Declare命令让RabbitMQ创建一个队列。像Exchange.Declare命令一样，该命令也会生成一个通信时序（见图2.9），如果Queue.Declare命令执行失败，信道将被关闭。

![image-20200721224431436](D:\data\notes\notes\消息队列\RabbitMQ\RabbitMQ协议和交互原理\image-20200721224431436.png)

在声明一个队列时，多次发送同一个Queue.Declare命令并不会有任何副作用。RabbitMQ不会处理后续的队列声明，只会返回队列相关的有用信息，比如队列中待处理消息的数量以及订阅该队列的消费者数量。

#### 优雅地处理错误

当你尝试声明一个与现有队列同名的新队列时，如果新队列的属性与现有队列不一样，那么RabbitMQ将关闭发出RPC请求的信道。这种行为与你的客户端应用程序向代理服务器发送命令时可能发生的任何其他类型的错误一致。例如，如果一个用户发出Queue.Declare命令，而该用户并没有在虚拟主机上被配置相应的访问权限时，该信道将关闭并显示403错误。要正确处理错误，你的客户端应用程序应该监听来自RabbitMQ的Channel.Close命令以便能够正确响应。某些客户端库可能会将此信息当作一种异常，然后让你的应用程序去处理。而其他客户端可能会使用回调风格，通过注册一个回调方法在Channel.Close命令到来时自动触发。如果你的客户端应用程序没有监听或处理来自服务器的事件，则可能会丢失消息。如果你向一个不存在或已关闭的信道发送消息，RabbitMQ可能会关闭连接。如果你的应用程序不知道RabbitMQ已经关闭了信道，那么在消费消息时可能不知道RabbitMQ已经停止向你的客户端发送消息，而仍然认为它运行正常并订阅了一个空队列。

### 绑定队列到交换器

一旦创建了交换器和队列，是时候将它们绑定在一起了。如同Queue.Declare命令，将队列绑定到交换器的Queue.Bind命令每次只能指定一个队列。与Exchange.Declare和Queue.Declare命令类似，在发出Queue.Bind命令后，如果处理成功，那么你的应用程序会收到一个Queue.BindOk方法帧（见图2.10）

![image-20200721224631382](D:\data\notes\notes\消息队列\RabbitMQ\RabbitMQ协议和交互原理\image-20200721224631382.png)

### 发布消息到RabbitMQ

当发布消息到RabbitMQ时，多个帧封装了发送到服务器的消息数据。在实际的消息内容到达RabbitMQ之前，客户端应用程序发送一个Basic.Publish方法帧、一个内容头帧和至少一个消息体帧（见图2.11）。

![image-20200721224717179](D:\data\notes\notes\消息队列\RabbitMQ\RabbitMQ协议和交互原理\image-20200721224717179.png)

当RabbitMQ接收到一个消息的所有帧并确定下一步操作之前，它将检查方法帧以获取它所需要的信息。Basic.Publish方法帧携带消息的交换器名称和路由键。在评估这些数据时，RabbitMQ会尝试将Basic.Publish帧中的交换器名称与配置交换器的数据库进行匹配。

当RabbitMQ发现某一个交换器与Basic.Properties方法帧中的交换器名称相匹配时，它将判断该交换器中的绑定信息，并通过路由键寻找匹配的队列。当消息与任一绑定的队列符合匹配标准时，RabbitMQ服务器将以FIFO的顺序将消息放入队列中。放入队列数据结构中的并不是实际消息，而是消息的引用。当RabbitMQ准备投递消息时，它将使用这个引用来编组消息并通过网络进行发送。这为发布到多个队列的消息提供了实质性的优化。当把消息发送到多个目标时，只保存消息的一个实例会占用较少的物理内存。某一个队列中的消息处理方式，无论是被消费、过期还是等待消费，都不会影响该消息在其他队列中的处理方式。一旦RabbitMQ不再需要这个消息，因为它的所有副本都已经被投递或者被删除了，单个消息数据将被从RabbitMQ的内存中移除。

### 从RabbitMQ中消费消息

要消费RabbitMQ队列中的消息，消费者应用程序通过发出Basic.Consume命令来订阅RabbitMQ中的队列。像其他同步命令一样，服务器将使用Basic.ConsumeOk进行响应，让客户端知道它将打开闸门并释放一大堆消息，或者至少是一两条消息。在RabbitMQ的说明文档中，消费者将开始通过我们已经熟悉的一种格式接收消息，这种格式包括对应的Basic.Deliver方法和它们的内容头以及消息体帧（见图2.12）

![image-20200721224904363](D:\data\notes\notes\消息队列\RabbitMQ\RabbitMQ协议和交互原理\image-20200721224904363.png)

一旦发送完Basic.Consume命令，消费者将处于活跃状态，直到某些事件中的其中一个被触发。如果消费者想要停止接收消息，则可以发出一个Basic.Cancel命令。值得注意的是，这个命令是异步发出的，而RabbitMQ可能仍然在发送消息，所以消费者在接收到一个Basic.CancelOk响应帧之前仍然可以接收到RabbitMQ预分配给它的任意数量的消息。