# 堆

堆常用于实现"优先队列"(priority queues)

优先队列是一种数据结构,可以自由添加数据,但是取出数据时要从最小值开始按顺序取出

在堆的树形结构中,各个定点被称为"节点"(node),数据存储在节点中

`堆中存储数据时必须遵守 : 子节点必定大于父节点.因此最小值被存储在顶端的根节点.往堆中添加数据时,为了遵守这条规则,一般会把新数据放在最下面一行靠左的位置,当最下面没有多余空间时就往下另起一行,把数据加在这一行的最左端.`

![image-20191227150613314](D:\data\notes\notes\计算机基础\数据结构和算法\堆\image-20191227150613314.png)

堆中的每个节点最多有两个子节点,树的形状取决于数据的个数,节点的排列顺序为从上到下,同一行里则为从左至右

![image-20191227151101037](D:\data\notes\notes\计算机基础\数据结构和算法\堆\image-20191227151101037.png)

往堆里添加数据 5 

![image-20191227151158222](D:\data\notes\notes\计算机基础\数据结构和算法\堆\image-20191227151158222.png)

![image-20191227151208336](D:\data\notes\notes\计算机基础\数据结构和算法\堆\image-20191227151208336.png)

![image-20191227151217614](D:\data\notes\notes\计算机基础\数据结构和算法\堆\image-20191227151217614.png)

![image-20191227151228609](D:\data\notes\notes\计算机基础\数据结构和算法\堆\image-20191227151228609.png)

这样往堆里插入数据就完成了.

![image-20191227151305645](D:\data\notes\notes\计算机基础\数据结构和算法\堆\image-20191227151305645.png)

![image-20191227151314777](D:\data\notes\notes\计算机基础\数据结构和算法\堆\image-20191227151314777.png)

![image-20191227151323636](D:\data\notes\notes\计算机基础\数据结构和算法\堆\image-20191227151323636.png)

![image-20191227151334005](D:\data\notes\notes\计算机基础\数据结构和算法\堆\image-20191227151334005.png)

![image-20191227151344883](D:\data\notes\notes\计算机基础\数据结构和算法\堆\image-20191227151344883.png)

![image-20191227151400009](D:\data\notes\notes\计算机基础\数据结构和算法\堆\image-20191227151400009.png)

![image-20191227151409811](D:\data\notes\notes\计算机基础\数据结构和算法\堆\image-20191227151409811.png)

`堆中最顶端的数据始终最小，所以无论数据量有多少，取出最小值的时间复杂度都为O（1）。
另外，因为取出数据后需要将最后的数据移到最顶端，然后一边比较它与子结点数据的大小，一边往下移动，所以取出数据需要的运行时间和树的高度成正比。假设数据量为n，根据堆的形状特点可知树的高度为log27，那么重构树的时间复杂度便为O（logn）。
添加数据也一样。在堆的最后添加数据后，数据会一边比较它与父结点数据的大小，一边往上移动，直到满足堆的条件为止，所以添加数据需要的运行时间与树的高度成正比，也是o（logn）。`

## java实现最大堆

最大堆和最小堆是二叉堆的两种形式。
最大堆：根结点的键值是所有堆结点键值中最大者，且每个结点的值都比其孩子的值大。
最小堆：根结点的键值是所有堆结点键值中最小者，且每个结点的值都比其孩子的值小。

在最大堆中，设根节点索引从1开始，当父节点索引为i时，左孩子节点2*i , 右孩子索引2*i+1。