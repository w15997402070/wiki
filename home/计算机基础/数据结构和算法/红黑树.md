### 红黑树
红黑树和AVL树一样都对插入时间、删除时间和查找时间提供了最好可能的最坏情况担保。这不只是使它们在时间敏感的应用如实时应用（real time application）中有价值，而且使它们有在提供最坏情况担保的其他数据结构中作为建造板块的价值；例如，在计算几何中使用的很多数据结构都可以基于红黑树。

红黑树在函数式编程中也特别有用，在这里它们是最常用的持久数据结构（persistent data structure）之一，它们用来构造关联数组和集合，每次插入、删除之后它们能保持为以前的版本。除了O(logn) 的时间之外，红黑树的持久版本对每次插入或删除需要的O(logn)空间。

红黑树是2-3-4树的一种等同。换句话说，对于每个2-3-4树，都存在至少一个数据元素是同样次序的红黑树。在2-3-4树上的插入和删除操作也等同于在红黑树中颜色翻转和旋转。这使得2-3-4树成为理解红黑树背后的逻辑的重要工具，这也是很多介绍算法的教科书在红黑树之前介绍2-3-4树的原因，尽管2-3-4树在实践中不经常使用。

红黑树相对于AVL树来说，牺牲了部分平衡性以换取插入/删除操作时少量的旋转操作，整体来说性能要优于AVL树。

 ### 性质

```
1.红黑树是每个节点都带有颜色属性的二叉查找树，颜色为红色或黑色。在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求：

2.节点是红色或黑色。  
3.根是黑色。  
4.所有叶子都是黑色（叶子是NIL节点）。  
5.每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）  
6.从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。
```

下面是一个具体的红黑树的图例：

An example of a red-black tree  
这些约束确保了红黑树的关键特性：从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。结果是这个树大致上是平衡的。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树。

要知道为什么这些性质确保了这个结果，注意到性质4导致了路径不能有两个毗连的红色节点就足够了。最短的可能路径都是黑色节点，最长的可能路径有交替的红色和黑色节点。因为根据性质5所有最长的路径都有相同数目的黑色节点，这就表明了没有路径能多于任何其他路径的两倍长。

在很多树数据结构的表示中，一个节点有可能只有一个子节点，而叶子节点包含数据。用这种范例表示红黑树是可能的，但是这会改变一些性质并使算法复杂。为此，本文中我们使用"nil叶子"或"空（null）叶子"，如上图所示，它不包含数据而只充当树在此结束的指示。这些节点在绘图中经常被省略，导致了这些树好像同上述原则相矛盾，而实际上不是这样。与此有关的结论是所有节点都有两个子节点，尽管其中的一个或两个可能是空叶子。





### RBTree的旋转操作

旋转操作(Rotate)的目的是使节点颜色符合定义，让RBTree的高度达到平衡。
Rotate分为left-rotate（左旋）和right-rotate（右旋），区分左旋和右旋的方法是：待旋转的节点从左边上升到父节点就是右旋，待旋转的节点从右边上升到父节点就是左旋。

什么时候需要旋转

什么时候左旋转

什么时候右旋转

**左旋：**以某个结点作为支点(旋转结点)，其右子结点变为旋转结点的父结点，右子结点的左子结点变为旋转结点的右子结点，左子结点保持不变。

**右旋：**以某个结点作为支点(旋转结点)，其左子结点变为旋转结点的父结点，左子结点的右子结点变为旋转结点的左子结点，右子结点保持不变。

**变色：**结点的颜色由红变黑或由黑变红。

### 插入操作

`新插入的节点是红色的，插入修复操作如果遇到父节点的颜色为黑则修复操作结束。`也就是说，只有在父节点为红色节点的时候是需要插入修复操作的。

插入修复操作分为以下的三种情况，而且新插入的节点的父节点都是红色的：

1. 叔叔节点也为红色。
2. 叔叔节点为空，且祖父节点、父节点和新节点处于一条斜线上。
3. 叔叔节点为空，且祖父节点、父节点和新节点不处于一条斜线上。



#### 1. 叔叔节点也为红色

![image-20191231171217730](D:\data\notes\notes\计算机基础\数据结构和算法\红黑树\image-20191231171217730.png)

将父节点和叔叔节点与祖父节点的颜色互换，这样就符合了RBTRee的定义	

![image-20191231171345938](D:\data\notes\notes\计算机基础\数据结构和算法\红黑树\image-20191231171345938.png)

#### 2. 叔叔节点为空，且祖父节点、父节点和新节点处于一条斜线上。

##### 当一条斜线的节点都在左边

​	![image-20191231171652455](D:\data\notes\notes\计算机基础\数据结构和算法\红黑树\image-20191231171652455.png)

将0004节点进行右旋操作，并且和父节点0005互换颜色。

![image-20191231172412042](D:\data\notes\notes\计算机基础\数据结构和算法\红黑树\image-20191231172412042.png)

##### 当一条斜线的节点都在右边



![image-20191231172050390](D:\data\notes\notes\计算机基础\数据结构和算法\红黑树\image-20191231172050390.png)

将0012节点进行左旋操作，并且和父节点互换颜色。

![image-20191231172224565](D:\data\notes\notes\计算机基础\数据结构和算法\红黑树\image-20191231172224565.png)

#### 3. 叔叔节点为空，且祖父节点、父节点和新节点不处于一条斜线上。

![image-20191231173429192](D:\data\notes\notes\计算机基础\数据结构和算法\红黑树\image-20191231173429192.png)

将0007节点进行左旋，这样就从3转换成2了，然后针对2进行操作处理就行了。2操作做了一个右旋操作和颜色互换来达到目的。如果树的结构是下图的镜像结构，则只需要将对应的左旋变成右旋，右旋变成左旋即可。

