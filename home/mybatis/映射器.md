# 映射器

| 元素名称     | 描述                                 | 备注                                   |
| ------------ | ------------------------------------ | -------------------------------------- |
| select       | 查询语句                             | 可以自定义参数,返回结果集等            |
| insert       | 插入语句                             | 执行后返回一个整数,代表插入的条数      |
| update       | 更新语句                             | 执行后返回一个整数,代表更新的条数      |
| delete       | 删除语句                             | 执行后返回一个整数,代表删除的条数      |
| parameterMap | 定义参数映射关系                     | 即将被删除的元素,不建议使用            |
| sql          | 允许定义一部分SQL,然后再各个地方引用 | 例如列名,可以一次定义多个SQL语句中使用 |
| resultMap    | 用来描述从数据库结果集中来加载对象   | 提供映射规则                           |
| cache        | 给定命名空间的缓存配置               |                                        |
| cache-ref    | 其他命名空间缓存配置的引用           |                                        |

## select

| 元素          | 说明                                                         | 备注                                             |
| ------------- | ------------------------------------------------------------ | ------------------------------------------------ |
| id            | 它和Mapper的命名空间组合起来是唯一的，提供给MyBatis 调用     | 如果命名空间和id组合起来不唯一,MyBatis将抛出异常 |
| parameterType | 你可以给出类的全命名，也可以给出类的别名，但使用别名必须是MyBatis内部定义或者自定义的 | 我们可以选择JavaBean,Map等复杂的参数类型传递     |
| resultType    | 定义类的全路径,在允许自动匹配的情况下，结果集将通过JavaBean的规范映射 :或定义为int、double、float等参数也可以使用别名，但是要符合别名规范，不能和resultMap同时使用 |                                                  |
| resultMap     | 它是映射集的引用，将执行强大的映射功能，我们可以使用resultType或者resultMap其中的一个，resultMap可以给予我们自定义映射规则的机会 | 可以配置映射规则,级联,typehandler等              |
| flushCache    | 它的作用是在调用SQL后，是否要求MyBatis清空之前查询的本地缓存和二级缓存 | 取值为布尔值，true/false。默认值为false          |
| useCache      | 启动二级缓存的开关，是否要求MyBatis将此次结果缓存            | 取值为布尔值，true/false。默认值为false          |
| timeout       | 设置超时参数，等超时的时候将抛出异常，单位为秒               | 默认值是数据库厂商提供的JDBC驱动所设置的秒数     |
| fetchSize     | 获取记录的总条数设定                                         | 默认值是数据库厂商提供的JDBC驱动所设置的条数     |
| statementType | 告诉MyBatis 使用哪个JDBC的Statement工作，取值为STATEMENT（Statement）、PREPARED（PreparedStatement）、CallableStatement | 默认值为PREPARED                                 |
| resultSetType | 这是对JDBC的resultSet接口而言，它的值包括 FORWARD_ONLY（游标允许向前访问）、SCROLL_SENSITIVE（双向滚动，但不及时更新，就是如果数据库里的数据修改过，并不在resultSet中反应出来）、SCROLL_INSENSITIVE（双向滚动，并及时跟踪数据库的更新，以便更改resultSet中的数据） | 默认值是数据库厂商提供的JDBC驱动所设置的         |
| databaseId    | databaseldProvider数据库厂商标识这部分内容                   | 提供多种数据库的支持                             |
| resultOrderd  | 这个设置仅适用于嵌套结果集select语句。如果为true，就是假设包含了嵌套结果集或者是分组了。当返回一个主结果行的时候，就不能对前面结果集的引用。这就确保了在获取嵌套的结果集的时候不至于导致内存不够用 | 取值为布尔值，true/false。默认值为false          |
| resultSets    | 适合于多个结果集的情况，它将列出执行SQL后每个结果集的名称，每个名称之间用逗号分隔 | 很少使用                                         |



### 自动映射功能

自动映射可以在`settings`元素中配置`autoMappingBehavior` 属性值来设置其策略。它包含3个值。

* NONE，取消自动映射。
* PARTIAL，只会自动映射，没有定义嵌套结果集映射的结果集。
* FULL，会自动映射任意复杂的结果集（无论是否嵌套）。

如果你的数据库是规范命名的，即每一个单词都用下划线分隔，POJO采用驼峰式命名方法，那么你也可以设置`mapUnderscore ToCamelCase`为true，这样就可以实现从数据库到POJO的自动映射了。

### 传递多个参数

#### 使用map接口

```java
List<User> findUserByMap(Map<String,String> paramMap);

<select id="findUserByMap" parameterType = "map">
    sql
</select>
```



#### 使用注解方式传递参数

```java
@Param(org.apache.ibatis.annotations.Param)

List<User> findUserByParams(@Param("username")String username);
```

#### 使用JavaBean传递参数

```java 
List<User> findUserByJavaBean(User user);

<select id="findUserByMap" parameterType = "com.domin.User">
    sql
</select>
```

### 使用resultMap映射结果集

```xml
<resultMap type="org.apache.ibatis.submitted.rounding.User" id="usermap">
		<id column="id" property="id"/>
		<result column="name" property="name"/>
		<result column="funkyNumber" property="funkyNumber"/>
		<result column="roundingMode" property="roundingMode"/>
</resultMap>

<select id="getUser" resultMap="usermap">
		select * from users
</select>
```

## insert 元素

insert元素，相对于select元素而言要简单多。MyBatis会在执行插入之后返回一个整数，以表示你进行操作后插入的记录数

![insert元素配置](C:\Users\Administrator.USER-20160923BV\AppData\Roaming\Typora\typora-user-images\1568643150023.png)

![配置2](C:\Users\Administrator.USER-20160923BV\AppData\Roaming\Typora\typora-user-images\1568643176682.png)



### 主键回填和自定义

#### Mysql主键自增

首先我们可以使用keyProperty属性指定哪个是主键字段，同时使用useGeneratedKeys属性告诉MyBatis 这个主键是否使用数据库内置策略生成。

```xml
<insert id="insert" keyProperty="id" useGeneratedKeys="true" >
    insert into users ( name, funkyNumber, roundingMode) values (
	    	 #{name}, #{funkyNumber}, #{roundingMode}
	    )
</insert>
```

#### 不能自增的数据库处理

```xml
<insert id="insert" parameterType="org.apache.ibatis.submitted.multidb.User">
		<selectKey keyProperty="id" resultType="int" order="BEFORE">
			<if test="_databaseId == 'hsql'">
				select max(id) + 1 from hsql
			</if>
			<if test="_databaseId != 'hsql'">
				select max(id) + 1 from common
			</if>
		</selectKey>
		<if test="_databaseId == 'hsql'">
			insert into hsql values (#{id}, #{name})
		</if>
		<if test="_databaseId != 'hsql'">
			insert into common values (#{id}, #{name})
		</if>
	</insert>
```

## update和delete元素

update元素和delete元素后会返回一个整数，标出执行后影响的记录条数。

```xml
<sql id="update">
        update users set name = #{name} where id = #{id}
    </sql>

Integer updateReturnsInteger(User user);

<update id="updateReturnsInteger" parameterType="org.apache.ibatis.submitted.dml_return_types.User">
        <include refid="update"/>
</update>
```

```xml
<delete id="delete" parameterType="UserAlias">
    DELETE FROM user WHERE id = #{id:INTEGER}
  </delete>

```

## resultMap元素

```xml
<resultMap>
    <!-- 构造方法-->
  <constructor>
      <idArg/>
      <arg/>
  </constructor>
    <!-- 配置主键-->
   <id/>
    <!-- 配置POJO到sql的映射-->
   <result/>
   <association></association>
   <collection></collection>
   <discriminator>
     <case></case>
   </discriminator>
</resultMap>
```

## 使用map存储结果集

```xml
<select id="simpleSelect" parameterType="Parameter" resultType="map">  
    select *  from names 
    <where>    
        <foreach collection="names" item="name" separator="or">      lastName =            #{name.lastName}    
        </foreach>  
    </where>
</select>
```

## 使用POJO存储结果集

```xml
<resultMap id="personMapComplex" type="Person">
        <id property="id" column="id"/>
        <result property="firstName" column="firstName"/>
        <result property="lastName" column="lastName"/>
        <association property="parent" column="{firstName=parent_firstName,lastName=parent_lastName}" select="getParentWithComplex"/>
    </resultMap>

<select id="getParentWithComplex" resultMap="personMapComplex">
        SELECT id, firstName, lastName, parent_id, parent_firstName, parent_lastName
        FROM Person
        WHERE firstName = #{firstName,jdbcType=VARCHAR}
        AND lastName = #{lastName,jdbcType=VARCHAR}
        LIMIT 1
    </select>	

<select id="getWithComplex" resultMap="personMapComplex" parameterType="long">
        SELECT id, firstName, lastName, parent_id, parent_firstName, parent_lastName
        FROM Person
        WHERE id = #{id,jdbcType=INTEGER}
    </select>
```

## 级联

Mybatis中级联分为3种 : 

* association : 代表`一对一关系`
* collection : 代表`一对多关系`
* discriminator : 是鉴别器，它可以根据实际选择采用哪个类作为实例，允许你根据特定的条件去关联不同的结果集。比如，人有男人和女人。你可以实例化一个人的对象，但是要根据情况用男人类或者用女人类去实例化。

### association

```xml
<resultMap id="blogWithPostsLazy" type="Blog">
    <id property="id" column="id"/>
    <result property="title" column="title"/>
    <association property="author" column="author_id" select="org.apache.ibatis.domain.blog.mappers.AuthorMapper.selectAuthorWithInlineParams" fetchType="lazy"/>
    <collection property="posts" column="id" select="selectPostsForBlog" fetchType="lazy"/>
  </resultMap>

<select id="selectBlogWithPostsUsingSubSelectLazily" parameterType="int" resultMap="blogWithPostsLazy">
    select * from Blog where id = #{id}
  </select>
<!-- 和上面的sql在不同的mapper,对应上面resultMap中association中select配置的 -->
<mapper namespace="org.apache.ibatis.domain.blog.mappers.AuthorMapper">
   <select id="selectAuthorWithInlineParams" parameterType="int"
		resultType="org.apache.ibatis.domain.blog.Author">
		select * from author where id = #{id}
	</select>
</mapper>
```

### collection

```xml
<resultMap id="blogWithPostsLazy" type="Blog">
    <id property="id" column="id"/>
    <result property="title" column="title"/>
    <association property="author" column="author_id" select="org.apache.ibatis.domain.blog.mappers.AuthorMapper.selectAuthorWithInlineParams" fetchType="lazy"/>
    <collection property="users" column="id" select="selectUsersForBlog" fetchType="lazy"/>
  </resultMap>

<select id="selectBlogWithPostsUsingSubSelectLazily" parameterType="int" resultMap="blogWithPostsLazy">
    select * from Blog where id = #{id}
  </select>
<!-- 对应上面resultMap中collection中select配置的 -->
<select id="selectUsersForBlog" parameterType="int" resultType="User">
    select * from User where blog_id = #{blog_id}
  </select>
```

### discriminator

```xml
 <resultMap id="personMap2" type="Person">
        <id property="id" column="id"/>
        <result property="firstName" column="firstName"/>
        <result property="lastName" column="lastName"/>
        <discriminator column="personType" javaType="String">
            <case value="EmployeeType">
                <discriminator column="employeeType" javaType="String">
                    <case value="DirectorType" resultMap="directorMap"/>
                </discriminator>
            </case>
        </discriminator>
    </resultMap>

   <resultMap id="personMap" type="Person">
        <id property="id" column="id"/>
        <result property="firstName" column="firstName"/>
        <result property="lastName" column="lastName"/>
        <discriminator column="personType" javaType="String">
            <case value="EmployeeType" resultMap="employeeMap"/>
        </discriminator>
    </resultMap>

  <resultMap id="employeeMap" type="Employee" extends="personMap">
        <result property="jobTitle" column="jobTitle"/>
        <discriminator column="employeeType" javaType="String">
            <case value="DirectorType" resultMap="directorMap"/>
        </discriminator>
    </resultMap>

   <resultMap id="directorMap" type="Director" extends="employeeMap">
        <result property="department" column="department"/>
    </resultMap>

<select id="get2" resultMap="personMap2" parameterType="long">
        SELECT id, firstName, lastName, jobTitle, department, personType, employeeType
        FROM Person
        WHERE id = #{id}
</select>
```

### 延迟加载

在MyBatis的配置中有两个全局的参数`lazyLoadingEnabled`和`aggressiveLazyLoading`。
`lazyLoadingEnabled`的含义是是否开启延迟加载功能。`aggressiveLazyLoading`的含义是对任意延迟属性的调用会使带有延迟加载属性的对象完整加载；反之，每种属性将按需加载。
`lazyLoadingEnabled` 是好理解的，而`aggressiveLazyLoading`则不是那么好理解了，别担心，它们很有趣，我们将在下面讨论它们，这样读者便能理解它们的机制了。

## 缓存 cache

### 一级缓存

MyBatis对缓存提供支持，但是在没有配置的默认的情况下，它只开启一级缓存（一级缓存只是相对于同一个SqlSession而言）。

所以在参数和SQL完全一样的情况下，我们使用同一个SqlSesion 对象调用同一个Mapper的方法，往往只执行一次SQL，因为使用SqlSession第一次查询后，MyBatis会将其放在缓存中，以后再查询的时候，如果没有声明需要刷新，并且缓存没超时的情况下，SqlSession 都只会取出当前缓存的数据，而不会再次发送SQL到数据库。
但是如果你使用的是不同的SqlSesion对象，因为不同的SqlSession都是相互隔离的，所以用相同的Mapper、参数和方法，它还是会再次发送SQL到数据库去执行，返回结果。

### 二级缓存

`SqlSesionFactory`层面上的二级缓存是不开启的，二级缓存的开启需要进行配置，实现二级缓存的时候，MyBatis要求返回的POJO必须是可序列化的，也就是要求实现Serializable接口，配置的方法很简单，只需要在映射XML文件配置就可以开启缓存了。

```xml
<cache/>
```

这样的一个语句里面，很多设置是默认的，如果我们只是这样配置，那么就意味着：

* 映射语句文件中的所有select 语句将会被缓存。
* 映射语句文件中的所有insert、update和delete语句会刷新缓存。
* 缓存会使用默认的Least Recently Used（LRU，最近最少使用的）算法来收回。
* 根据时间表，比如No Flush Interval，（CNFI，没有刷新间隔），缓存不会以任何时间顺序来刷新。
* 缓存会存储列表集合或对象（无论查询方法返回什么）的1024个引用。
* 缓存会被视为是read/write（可读/可写）的缓存，意味着对象检索不是共享的，而且可以安全地被调用者修改，不干扰其他调用者或线程所做的潜在修改。

#### 配置缓存

```xml
<cache eviction="LRU" flushInterval="100000" size="1024" readOnly="true"></cache>
```

* eviction：代表的是缓存回收策略，目前MyBatis 提供以下策略。
  （1）`LRU`，最近最少使用的，移除最长时间不用的对象。
  （2）`FIFO`，先进先出，按对象进入缓存的顺序来移除它们。
  （3）`SOFT`，软引用，移除基于垃圾回收器状态和软引用规则的对象。
  （4）`WEAK`，弱引用，更积极地移除基于垃圾收集器状态和弱引用规则的对象。这里采用的是LRU，移除最长时间不用的对象。
* `flushlnterval`：刷新间隔时间，单位为毫秒，这里配置的是100秒刷新，如果你不配置它，那么当SQL被执行的时候才会去刷新缓存。
* `size`：引用数目，一个正整数，代表缓存最多可以存储多少个对象，不宜设置过大。设置过大会导致内存溢出。这里配置的是1024个对象。
* `readOnly`：只读，意味着缓存数据只能读取而不能修改，这样设置的好处是我们可以快速读取缓存，缺点是我们没有办法修改缓存，它的默认值为false，不允许我们修改。

#### 自定义缓存

需要实现Mybatis提供的接口`org.apache.ibatis.cache.Cache`

```java
/**
 * 缓存
 *
 */
public interface Cache {

    //取得ID
  String getId();

  //存入值
  void putObject(Object key, Object value);

  //获取值
  Object getObject(Object key);

  //删除值
  Object removeObject(Object key);

  //清空
  void clear();

  //取得大小
  int getSize();
  
  //取得读写锁, 从3.2.6开始没用了，要SPI自己实现锁
  ReadWriteLock getReadWriteLock();

}
```

例如自己的实现类 `com.test.MyCache`

```xml
<cache type="com.test.MyCache"/>
```

设置自定义缓存参数 :

```xml
<cache type="com.test.MyCache">
    <property name="host" value="localhost"/>
</cache>
```

如果我们在MyCache这个类增加`setHost（String host）`方法，那么它在初始化的时候就会被调用，这样你可以对自定义设置一些外部参数。